# -*- coding: utf-8 -*-
# =============================================================
#  BOT TU TI√äN ‚Äî NTH3.2 (Module, no-self) (BT-1727-KIM)
#  Phi√™n b·∫£n: v18_9 ‚Üí NTH3.2 (Module, no-self) Big Update (2025-10-30)
#  Changelog:
#   - T√°i c·∫•u tr√∫c to√†n b·ªô file th√†nh c√°c KHU V·ª∞C r√µ r√†ng (Emoji, Link ·∫¢nh, Kinh T·∫ø, Nh√¢n V·∫≠t, Trang B·ªã, Qu·∫£n L√Ω: Admin, Qu·∫£n L√Ω: Ch·ªß bot).
#   - ƒê√≥ng g√≥i l·ªánh theo t·ª´ng Cog ƒë·ªôc l·∫≠p (module h√≥a), gi·∫£m ph·ª• thu·ªôc ch√©o.
#   - Gi·ªØ nguy√™n to√†n b·ªô t√≠nh nƒÉng hi·ªán c√≥ (ol/omo/oban/okho/omac/othao/oxem/onhanvat/odt + jackpot, setbot, backup v16...).
#   - B·ªï sung ‚Äúh·ªá tham chi·∫øu chung‚Äù g·ªìm: d·ªØ li·ªáu, backup, c·∫•u h√¨nh k√™nh, emoji, ·∫£nh, rarity, m√¥ t·∫£.
#   - B·ªô l·ªçc k√™nh gameplay (osetbot) + b·ªè c·∫£nh b√°o ‚Äúok/oh/ob/‚Ä¶‚Äù v·∫´n ho·∫°t ƒë·ªông.
#   - Chu·∫©n b·ªã n·ªÅn t·∫£ng cho c√°c Big Update ti·∫øp theo m√† kh√¥ng ·∫£nh h∆∞·ªüng module kh√°c.
# =============================================================

# =========================
# üîß H·ªÜ THAM CHI·∫æU CHUNG ‚Äî B·∫ÆT ƒê·∫¶U
# (Core: import, d·ªØ li·ªáu, backup v16, c·∫•u h√¨nh k√™nh, emoji, ·∫£nh, rarity, m√¥ t·∫£, helpers)
# =========================
import os, io, json, time, random, asyncio, logging, hashlib, tempfile
from glob import glob
from datetime import datetime
# üîß H·ªÜ THAM CHI·∫æU CHUNG ‚Äî B·∫ÆT ƒê·∫¶U
# (Core: import, d·ªØ li·ªáu, backup v16, c·∫•u h√¨nh k√™nh, emoji, ·∫£nh, rarity, m√¥ t·∫£, helpers)
# =========================
import os, io, json, time, random, asyncio, logging, hashlib, tempfile
from glob import glob
from datetime import datetime
import discord
from discord.ext import commands
import aiohttp

logging.getLogger("discord").setLevel(logging.WARNING)

INTENTS = discord.Intents.default()
INTENTS.message_content = True
INTENTS.members = True


COOLDOWN_OL = 10
STARTING_NP = 1000

# ‚Äî‚Äî‚Äî Whitelist t·ª´ ‚Äòo‚Ä¶‚Äô kh√¥ng b√°o l·ªói CommandNotFound ‚Äî‚Äî‚Äî
IGNORE_O_TOKENS = {"ok","oh","ob","oke","okay","ooo","oi"}

# ===== H·ªÜ TH·ªêNG BACKUP v16 =====
BACKUP_DIRS = {
    "startup": "backups/startup",
    "pre_save": "backups/pre-save",
    "manual": "backups/manual",
    "before_restore": "backups/before-restore",
    "resetuser": "backups/resetuser",
    "export": "backups/export"
}
def _ensure_backup_dirs():
    for p in BACKUP_DIRS.values():
        os.makedirs(p, exist_ok=True)
def _stamp_now():
    return datetime.now().strftime("%Y%m%d-%H%M%S")
def _sha256_file(path):
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest()
def snapshot_data_v16(data, tag, subkey):
    _ensure_backup_dirs()
    stamp = _stamp_now()
    fname = f"data.json.v16.{tag}.{stamp}.json"
    dstdir = BACKUP_DIRS.get(subkey, BACKUP_DIRS["manual"])
    out = os.path.join(dstdir, fname)
    with open(out, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    with open(out + ".sha256", "w", encoding="utf-8") as g:
        g.write(_sha256_file(out))
    return out
def list_recent_backups_v16(limit=10):
    _ensure_backup_dirs()
    files = []
    for key, d in BACKUP_DIRS.items():
        for p in glob(os.path.join(d, "data.json.v*.json")):
            files.append((os.path.getmtime(p), key, p))
    files.sort(reverse=True)
    return files[:max(1, min(20, limit))]
def total_backup_stats_v16():
    _ensure_backup_dirs()
    total_files = 0; total_bytes = 0; latest = None
    for key, d in BACKUP_DIRS.items():
        for p in glob(os.path.join(d, "data.json.v*.json")):
            total_files += 1
            total_bytes += os.path.getsize(p)
            mt = os.path.getmtime(p)
            if (latest is None) or (mt > latest[0]):
                latest = (mt, p)
    return {"files": total_files, "bytes": total_bytes, "latest": latest[1] if latest else None}

# ===== D·ªÆ LI·ªÜU & TI·ªÜN √çCH CHUNG =====
SESSION: aiohttp.ClientSession | None = None
IMG_CACHE: dict[str, bytes] = {}

async def get_session() -> aiohttp.ClientSession:
    global SESSION
    if SESSION is None or SESSION.closed:
        connector = aiohttp.TCPConnector(limit=8)
        SESSION = aiohttp.ClientSession(connector=connector)
    return SESSION

async def file_from_url_cached(url: str, filename: str) -> discord.File:
    if url not in IMG_CACHE:
        sess = await get_session()
        async with sess.get(url, timeout=aiohttp.ClientTimeout(total=10)) as resp:
            resp.raise_for_status()
            IMG_CACHE[url] = await resp.read()
    return discord.File(io.BytesIO(IMG_CACHE[url]), filename=filename)

def ensure_data():
    if not os.path.exists(DATA_FILE):
        with open(DATA_FILE, "w", encoding="utf-8") as f:
            json.dump({"bot_channel": None, "active": False, "users": {}}, f, ensure_ascii=False, indent=2)

def load_data():
    ensure_data()
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
    except json.JSONDecodeError:
        data = {"users": {}, "bot_channel": None, "active": False}
    data.setdefault("users", {})
    data.setdefault("bot_channel", None)
    data.setdefault("active", False)
    data.setdefault("guild_settings", {})
    data.setdefault("server_cfg", {})
    data.setdefault("config", {"images_enabled": True})
    return data

def save_data(data):
    try:
        snapshot_data_v16(data, tag="pre-save", subkey="pre_save")
    except Exception:
        pass
    dir_ = os.path.dirname(os.path.abspath(DATA_FILE)) or "."
    fd, tmp_path = tempfile.mkstemp(prefix="data_", suffix=".json", dir=dir_)
    os.close(fd)
    with open(tmp_path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    os.replace(tmp_path, DATA_FILE)

def ensure_user(user_id:str):
    data = load_data()
    if user_id not in data["users"]:
        data["users"][user_id] = {
            "ngan_phi": STARTING_NP,
            "rungs": {"D":0,"C":0,"B":0,"A":0,"S":0},
            "items": [],
            "equipped": {"slot_vukhi": None, "slot_aogiap": None},
            "cooldowns": {"ol":0},
            "stats": {"opened":0,"ol_count":0,"ngan_phi_earned_total":0,"sold_count":0,"sold_value_total":0},
            "claimed_missions": [],
            "achievements": [],
            "minigames": {"odt": {"win_streak": 0, "loss_streak": 0}}
        }
        save_data(data)
    return data

def format_num(n:int)->str:
    return f"{n:,}"

def make_embed(title, description="", fields=None, color=0x9B5CF6, thumb=None, image=None, footer=None):
    emb = discord.Embed(title=title, description=description, color=color)
    if fields:
        for n,v,inline in fields:
            emb.add_field(name=n, value=v, inline=inline)
    if thumb: emb.set_thumbnail(url=thumb)
    if image: emb.set_image(url=image)
    if footer: emb.set_footer(text=footer)
    return emb

# ===== C·∫§U H√åNH K√äNH (osetbot ‚Äì nhi·ªÅu k√™nh) =====
def _sv_cfg(data, guild_id: int) -> dict:
    root = data.setdefault("server_cfg", {})
    return root.setdefault(str(guild_id), {})

def get_guild_channels(data, guild_id: int) -> set[int]:
    cfg = _sv_cfg(data, guild_id)
    lst = cfg.get("bot_channels")
    if isinstance(lst, list) and lst:
        try:
            return {int(x) for x in lst}
        except Exception:
            pass
    # t∆∞∆°ng th√≠ch c≈©
    rec = data.setdefault("guild_settings", {}).setdefault(str(guild_id), {})
    legacy = rec.get("channel_id")
    if legacy:
        try: return {int(legacy)}
        except Exception: return set()
    return set()

def set_guild_channels_only(data, guild_id: int, channel_id: int):
    cfg = _sv_cfg(data, guild_id)
    cfg["bot_channels"] = [int(channel_id)]

def add_guild_channel(data, guild_id: int, channel_id: int, max_channels: int = 5) -> bool:
    cfg = _sv_cfg(data, guild_id)
    cur = list(get_guild_channels(data, guild_id))
    if int(channel_id) in cur: return True
    if len(cur) >= max_channels: return False
    cur.append(int(channel_id))
    cfg["bot_channels"] = cur
    return True

def remove_guild_channel(data, guild_id: int, channel_id: int) -> bool:
    cfg = _sv_cfg(data, guild_id)
    cur = list(get_guild_channels(data, guild_id))
    if int(channel_id) not in cur: return False
    cur = [c for c in cur if int(c) != int(channel_id)]
    cfg["bot_channels"] = cur
    return True

# ===== Emoji ‚Äî B·∫ÆT ƒê·∫¶U =====
# (Khu v·ª±c Emoji d√πng chung to√†n d·ª± √°n)
RARITY_EMOJI = {
    "D": "<a:D12:1432473477616505023>",
    "C": "<a:C11:1432467636943454315>",
    "B": "<a:B11:1432467633932075139>",
    "A": "<a:A11:1432467623051919390>",
    "S": "<a:S11:1432467644761509948>",
}
RARITY_CHEST_EMOJI = {
    "D": "<a:rd_d:1431717925034918052>",
    "C": "<a:rc_d:1431713192123568328>",
    "B": "<a:rb_d:1431713180975108291>",
    "A": "<a:ra_d:1431713170384490726>",
    "S": "<a:rs_d:1432101376699269364>",
}
RARITY_CHEST_OPENED_EMOJI = {
    "D": "<a:rd_m:1431717929782870116>",
    "C": "<a:rc_m:1431713195860693164>",
    "B": "<a:rb_m:1431713187924934686>",
    "A": "<a:ra_m:1431713174704492604>",
    "S": "<a:rs_m:1431717941065547866>",
}
EMOJI_MORUONG = "<a:rd_m:1431717929782870116>"
EMOJI_TRANG_BI_COUNT = "<:motrangbi:1431822388793704508>"
NP_EMOJI = "<a:np:1431713164277448888>"
EMOJI_NOHU4 = "<a:nohu5:1432589822740004934>"
EMOJI_CANHBAO = "<:thongbao:1432852057353621586>"
EMOJI_THONGBAO = "<:canhbao:1432848238104543322>"
EMOJI_DOTHACH      = "<a:dothach:1431793311978491914>"
EMOJI_DOTHACHT     = "<:dothacht:1431806329529303041>"
EMOJI_DOTHACH1     = "<a:dothach1:1432592899694002286>"
EMOJI_DOTHACHTHUA  = "<:dothachthua:1432755827621757038>"
# ===== Emoji ‚Äî K·∫æT TH√öC =====

# ===== Link H√¨nh ·∫¢nh ‚Äî B·∫ÆT ƒê·∫¶U =====
IMG_BANDO_DEFAULT = "https://i.postimg.cc/15CvNdQL/bando.png"
IMG_RUONG_MO = "https://i.ibb.co/21NS0t10/ruongdamo.png"
IMG_NGAN_PHIEU = "https://i.ibb.co/DDrgRRF1/nganphieu.png"
IMG_KHO_DO = "https://i.postimg.cc/W3189R0f/thungdo-min.png"
IMG_NHAN_VAT = "https://sv2.anhsieuviet.com/2025/10/29/nhanvat-min.png"
ITEM_IMAGE = {
    "Ki·∫øm": "https://i.ibb.co/6pDBWyR/kiem.png",
    "Th∆∞∆°ng": "https://i.ibb.co/S2C7fwJ/thuong.png",
    "ƒê√†n": "https://i.ibb.co/Fk0rSpQg/dan.png",
    "Tr∆∞·ª£ng": "https://i.ibb.co/ymbxhtg5/truong.png",
    "D·∫£i L·ª•a": "https://i.ibb.co/Myx1fD34/dailua.png",
    "GƒÉng Tay": "https://i.ibb.co/gbn2Q6Gx/gangtay.png",
    "√Åo Gi√°p": "https://i.ibb.co/jkWkT5hj/giap.png"
}
RARITY_COLOR = {"D":0x8B6B46,"C":0x2F80ED,"B":0x8A2BE2,"A":0xFF6A00,"S":0xFFD700}
MAP_IMAGES = {
    "S": "https://sv2.anhsieuviet.com/2025/10/28/5-min.png",
    "A": "https://sv2.anhsieuviet.com/2025/10/28/4-min.png",
    "B": "https://sv2.anhsieuviet.com/2025/10/28/3-min.png",
    "C": "https://sv2.anhsieuviet.com/2025/10/28/2-min.png",
    "D": "https://sv2.anhsieuviet.com/2025/10/28/1-min.png",
}
# ===== Link H√¨nh ·∫¢nh ‚Äî K·∫æT TH√öC =====

# ===== Rarity, map, m√¥ t·∫£ loot ‚Äî B·∫ÆT ƒê·∫¶U =====
RARITY_PROBS = [("D",0.50),("C",0.30),("B",0.15),("A",0.04),("S",0.01)]
NGANPHIEU_RANGE = {"D":(1,5),"C":(5,10),"B":(10,500),"A":(500,2000),"S":(2000,50000)}
PROB_ITEM_IN_RUONG = 0.40
MAP_POOL = ["Bi·ªán Kinh","ƒê√†o Kh√™ Th√¥n","Tam Thanh S∆°n","H√†ng Ch√¢u","T·ª´ Ch√¢u","Nh·∫°n M√¥n Quan","Discord NTH Fan"]
ITEM_TYPES = ["Ki·∫øm","Th∆∞∆°ng","ƒê√†n","Tr∆∞·ª£ng","D·∫£i L·ª•a","GƒÉng Tay","√Åo Gi√°p"]
ITEM_VALUE_RANGE = {"D":(20,100),"C":(100,500),"B":(500,5000),"A":(5000,20000),"S":(20000,200000)}
ITEM_NAMES = {
    "Ki·∫øm":[("Ki·∫øm S·∫Øt","D"),("Ki·∫øm Lam Tinh","C"),("Ki·∫øm H√†n V√¢n","B"),("Ki·∫øm Tr√∫c Nguy·ªát","A"),("Ki·∫øm Th∆∞·ª£ng Th·∫ßn","S")],
    "Th∆∞∆°ng":[("Th∆∞∆°ng S∆°","D"),("Th∆∞∆°ng B√£o T·ªë","C"),("Th∆∞∆°ng Ti√™u H·ªìn","B"),("Th∆∞∆°ng Huy·ªÅn V≈©","A"),("Th∆∞∆°ng Ch·∫•n Thi√™n","S")],
    "ƒê√†n":[("ƒê√†n Tre","D"),("ƒê√†n Thanh","C"),("ƒê√†n H·ªìn Thanh","B"),("ƒê√†n Ph√°p Nguy·ªát","A"),("ƒê√†n Thi√™n Nh·∫°c","S")],
    "Tr∆∞·ª£ng":[("Tr∆∞·ª£ng G·ªó","D"),("Tr∆∞·ª£ng Ma","C"),("Tr∆∞·ª£ng Phong ·∫¢nh","B"),("Tr∆∞·ª£ng Linh Ng∆∞ng","A"),("Tr∆∞·ª£ng C√†n Kh√¥n","S")],
    "D·∫£i L·ª•a":[("L·ª•a T·∫ßm Th√¥n","D"),("L·ª•a Thanh","C"),("L·ª•a Huy·ªÖn Li·ªÖu","B"),("L·ª•a Ph∆∞·ª£ng Ho√†ng","A"),("L·ª•a M·ªã ·∫¢nh","S")],
    "GƒÉng Tay":[("GƒÉng V·∫£i","D"),("GƒÉng B√£o","C"),("GƒÉng Ma Ph√°p","B"),("GƒÉng Kim C∆∞∆°ng","A"),("GƒÉng V√¥ ·∫¢nh","S")],
    "√Åo Gi√°p":[("√Åo Da","D"),("√Åo Linh Phi","C"),("√Åo Ng·ª± V√¢n","B"),("√Åo H·∫Øc V√¥ C·ª±c","A"),("√Åo V√¥ Song","S")]
}

MAP_DISCORD = "Discord NTH Fan"
DESCRIPTIONS = {
    "D": [
        "B·∫°n d·∫°o quanh ch·ª£ ph√†m nh√¢n, b·∫•t ng·ªù ph√°t hi·ªán chi·∫øc r∆∞∆°ng g·ªó c≈© d∆∞·ªõi g·ªëc c√¢y.",
        "H√†nh t·∫©u giang h·ªì v·∫•p h√≤n ƒë√° l·∫° ‚Äî b√™n d∆∞·ªõi l√† r∆∞∆°ng ph·ªß r√™u.",
        "Tr·ªùi n·∫Øng ƒë·∫πp, b·∫°n l√™n n√∫i h√°i thu·ªëc ‚Äî ven ƒë∆∞·ªùng l·ªô ra r∆∞∆°ng g·ªó m·ªôc.",
        "Ho√†n th√†nh vi·ªác v·∫∑t ·ªü tr·∫•n nh·ªè, tr∆∞·ªüng l√£o th∆∞·ªüng cho b·∫°n r∆∞∆°ng b√© x√≠u.",
        "Gi·∫øng c·ªï l·ªô ƒë√° l·∫°, b·∫°n moi ra chi·∫øc r∆∞∆°ng s·ª©t m·∫ª.",
        "T·∫°i l√πm tr√∫c vang √¢m thanh kh·∫Ω, b·∫°n nh·∫∑t ƒë∆∞·ª£c r∆∞∆°ng mini.",
        "B√£o tan, g·ªëc c√¢y b·∫≠t r·ªÖ ‚Äî l·ªô ra r∆∞∆°ng ƒë·ªìng r·ªâ.",
        "ƒê·ªìng h√†nh c·∫£m t·∫°, t·∫∑ng b·∫°n r∆∞∆°ng nh·ªè b·ªçc v·∫£i.",
        "C·ª≠a h√†ng t·∫°p h√≥a b√°n r·∫ª m·ªôt r∆∞∆°ng c≈© kh√¥ng ch√¨a.",
        "B·∫øn thuy·ªÅn c√≥ bao t·∫£i d·∫°t v√†o, trong l√† r∆∞∆°ng g·ªó con.",
        "Khe n√∫i h·∫πp ph·∫£n quang, h√≥a ra l√† kh√≥a r∆∞∆°ng c≈©.",
        "Ti·ªÉu tƒÉng qu√™n ƒë·ªì, b·∫°n tr·∫£ l·∫°i ‚Äî ƒë∆∞·ª£c t·∫∑ng r∆∞∆°ng m·ªôc.",
        "S∆∞∆°ng s·ªõm ƒë·ªçng n·∫∑ng tr√™n n·∫Øp r∆∞∆°ng, b·∫°n kh·∫Ω m·ªü th·ª≠.",
        "L·ªÅu c·ªè b·ªè hoang, r∆∞∆°ng b√© b·ªã b·ª•i ph·ªß k√≠n.",
        "Ti·∫øng ve ng·ª´ng, m√πi g·ªó c≈© tho·∫£ng l√™n ‚Äî m·ªôt r∆∞∆°ng nh·ªè n·∫±m ƒë√≥.",
        "D∆∞·ªõi b·∫≠c ƒë√° mi·∫øu hoang, b·∫°n g·∫°t r√™u th·∫•y r∆∞∆°ng g√†i then.",
        "B·ªù ru·ªông c√≥ √°nh l·∫≠p l√≤e ‚Äî d√¢y leo che n·ª≠a chi·∫øc r∆∞∆°ng.",
        "B·∫°n ƒë·ªët l·ª≠a s∆∞·ªüi ƒë√™m, tro t√†n l·ªô ra m√©p r∆∞∆°ng v·ª°.",
        "Tr√™n t·∫•m bia s·ª•p c√≥ kh·∫Øc k√Ω hi·ªáu d·∫´n t·ªõi r∆∞∆°ng c≈©.",
        "M·ªôt con s√≥c tha nh·∫ßm ch√¨a kh√≥a, b·∫°n l·∫ßn theo v√† g·∫∑p r∆∞∆°ng m·ªôc."
    ],
    "C": [
        "B·∫°n r√∫t qu·∫ª ƒë·∫°i c√°t, may m·∫Øn nh·∫∑t ƒë∆∞·ª£c r∆∞∆°ng g·ªó ph√°t s√°ng nh·∫π.",
        "Ngh·ªâ ch√¢n b√™n su·ªëi nghe ti·∫øng ng√¢n ‚Äî r∆∞∆°ng ƒë·ªìng nho nh·ªè tr√¥i l√™n.",
        "B·∫°n v·∫•p ph·∫£i r∆∞∆°ng b√© lƒÉn t·ªõi nh∆∞ mu·ªën theo b·∫°n v·ªÅ.",
        "Gi√≥ ngh·ªãch th·ªïi r∆∞∆°ng mini ƒë·∫øn s√°t m≈©i gi√†y.",
        "Trong l√πm hoa, b∆∞·ªõm ƒë·∫≠u l√™n chi·∫øc r∆∞∆°ng nh·ªè kh·∫£m ƒëinh.",
        "Tuy·∫øt tan ƒë·ªÉ l·ªô r∆∞∆°ng ƒë∆°n s∆° n√©p trong bƒÉng m·ªèng.",
        "B·∫°n luy·ªán c√¥ng v·∫•p ƒë√° ‚Äî d∆∞·ªõi ƒë√≥ l√† r∆∞∆°ng c≈© ph·ªß b·ª•i.",
        "D·ªçn kho ch√πa hoang b·∫Øt g·∫∑p r∆∞∆°ng b√© b·ªã chu·ªôt tha v√†o g√≥c.",
        "L√†n kh√≥i ƒë√†n h∆∞∆°ng d·∫´n b·∫°n t·ªõi r∆∞∆°ng g·ªó kh·∫Øc ph√π.",
        "M∆∞a r√†o t·∫°nh, c·∫ßu v·ªìng chi·∫øu l√™n n·∫Øp r∆∞∆°ng nh·ªè.",
        "Ng∆∞ √¥ng c√∫ng b·∫°n r∆∞∆°ng l·∫° v·ªõt ngo√†i h·ªì.",
        "Ti·∫øng chu√¥ng xa ng√¢n, n·∫Øp r∆∞∆°ng kh·∫Ω rung theo nh·ªãp.",
        "ƒê√° t·∫£ng n·ª©t, khe h·ªü gi·∫•u r∆∞∆°ng mini b·ªçc l·ª•a.",
        "B·∫°n gi√∫p d√¢n l√†ng s·ª≠a ƒë√™, ƒë∆∞·ª£c t·∫∑ng r∆∞∆°ng nh·ªè tri √¢n.",
        "Tr√™n c√†nh c√¢y r·ªóng c√≥ r∆∞∆°ng g·ªó nh√©t v·ª´a tay.",
        "Chu√¥ng gi√≥ treo hi√™n tr·ªè h∆∞·ªõng ‚Äî b·∫°n th·∫•y r∆∞∆°ng nh·ªè.",
        "B∆∞·ªõc ch√¢n ch·∫°m b·∫≠c c·ªï th·ªÅm, vi√™n g·∫°ch r∆°i l·ªô r∆∞∆°ng con.",
        "ƒê·ªëm l·ª≠a ƒëom ƒë√≥m t·ª• l·∫°i quanh chi·∫øc r∆∞∆°ng tinh x·∫£o.",
        "B·∫°n nh·∫∑t l√° b√πa c·ªï, d∆∞·ªõi l√† r∆∞∆°ng g·ªó c√†i then.",
        "Ve s·∫ßu l·ªôt x√°c b√™n r∆∞∆°ng nh·ªè kh·∫Øc ƒë∆∞·ªùng v√¢n ƒë·∫πp."
    ],
    "B": [
        "B·∫°n th√°m hi·ªÉm ngo·∫°i th√†nh, ƒë√°nh lui du c√¥n ‚Äî thu ƒë∆∞·ª£c r∆∞∆°ng qu√Ω.",
        "ƒê√™m trƒÉng linh quang chi·∫øu xu·ªëng ‚Äî hi·ªán r∆∞∆°ng c·ªï ti·ªÅn tri·ªÅu.",
        "B·∫°n l·∫≠p c√¥ng b·∫Øt tr·ªôm, ƒë∆∞·ª£c th∆∞·ªüng r∆∞∆°ng kh√≥a ƒë·ªìng n·∫∑ng.",
        "Ph√° tr·∫≠n ph√°p ƒë∆°n s∆° trong hang t·ªëi ‚Äî r∆∞∆°ng b√≠ ·∫©n l·ªô ra.",
        "ƒê·∫©y l√πi c∆∞·ªõp ƒë∆∞·ªùng, r∆∞∆°ng r∆°i t·ª´ tay t√™n th·ªß lƒ©nh.",
        "S·ª≠a mi·∫øu th·ªù, sau b·ªá ƒë√° ·∫©n r∆∞∆°ng c·ªï ƒëinh ch·∫°m.",
        "Tr·∫≠n chi·∫øn v√°ch ƒë√° k·∫øt th√∫c, r∆∞∆°ng r∆°i ƒë√∫ng b√†n tay b·∫°n.",
        "Qua minh c·ªëc, chu√¥ng ƒë√° rung ‚Äî r∆∞∆°ng qu√Ω b·∫≠t n·∫Øp.",
        "H·ªì sen n·ªü r·ªô; g·ªëc sen d√≠nh r∆∞∆°ng ch·∫°m b·∫°c.",
        "Th∆∞ kh·ªë c≈© c√≥ h·ªôc b√≠ m·∫≠t, b√™n trong l√† r∆∞∆°ng kh·∫£m ƒë·ªìng.",
        "Qu·∫∑ng m·∫°ch ƒë·ªïi s·∫Øc, b·∫°n ƒë√†o l√™n r∆∞∆°ng tr√¢n ch√¢u.",
        "ƒê·ªânh n√∫i n·ªïi m√¢y t√≠m, r∆∞∆°ng m·∫° ƒë·ªìng hi·ªán d·∫•u ·∫•n gia t·ªôc.",
        "M·ªô c·ªï l·ªô ra ƒë·∫°o kh·∫©u, r∆∞∆°ng ch·∫°m th√∫ canh gi·ªØ.",
        "H·∫°c gi·∫•y ch·ªâ ƒë∆∞·ªùng ƒë∆∞a b·∫°n t·ªõi r∆∞∆°ng g·∫•m.",
        "M∆∞a sao bƒÉng r∆°i, r∆∞∆°ng s√°ng d·ªãu ƒë√°p b√™n ch√¢n.",
        "Ti·∫øng ti√™u tr√™n n√∫i g·ªçi b·∫°n t·ªõi r∆∞∆°ng kh·∫Øc long v√¢n.",
        "C·ª≠a ng·∫ßm V√¢n S∆°n m·ªü, r∆∞∆°ng qu√Ω t·ª´ t∆∞·ªùng tr∆∞·ª£t ra.",
        "C√¢y c·ªï th·ª• ti·∫øt nh·ª±a th∆°m, trong h·ªëc l√† r∆∞∆°ng b√≠ d∆∞·ª£c.",
        "L√≤ r√®n ngu·ªôi tro c√≤n ·∫•m, r∆∞∆°ng th√©p s·∫´m n·∫±m d∆∞·ªõi ƒëe.",
        "S·∫Øc ph√π c·ªï rung l√™n ‚Äî r∆∞∆°ng qu√Ω ƒë√°p ·ª©ng l·ªùi tri·ªáu."
    ],
    "A": [
        "Thi√™n v·∫≠n ch√∫ √Ω ‚Äî m·ªôt r∆∞∆°ng ng·ªçc hi·ªán ra gi·ªØa linh quang r·ª±c r·ª°.",
        "T·∫≠p khinh c√¥ng r∆°i v√†o khe ‚Äî ƒë√°y c√≥ r∆∞∆°ng b√°u l√≥e s√°ng.",
        "√Ånh linh l·ª±c t·ª• l·∫°i h√≥a r∆∞∆°ng ch√¢u s√°ng ng·ªùi.",
        "C·ªï th·ª• n·ªü hoa ƒë√™m, g·ªëc h√© r∆∞∆°ng th∆°m m√πi linh d∆∞·ª£c.",
        "Kh√≠ m·∫°ch ch·∫•n ƒë·ªông, r∆∞∆°ng ph√°t s√°ng bay v√≤ng quanh r·ªìi h·∫° xu·ªëng.",
        "Ti√™n h·∫°c s√† xu·ªëng, ƒë·∫∑t r∆∞∆°ng ch√¢u tinh x·∫£o v√†o tay b·∫°n.",
        "Kho·∫£nh kh·∫Øc ƒë·ªôt ph√° c·∫£nh gi·ªõi, ƒë·∫•t rung l·ªô r∆∞∆°ng b√°u ch·ªù s·∫µn.",
        "T√¢m b√£o tuy·∫øt t√°ch ƒë√¥i, r∆∞∆°ng v√†ng l∆° l·ª≠ng nh∆∞ ƒë·ª£i ch·ªß.",
        "D√≤ng su·ªëi h√≥a th√†nh g∆∞∆°ng, ph·∫£n chi·∫øu r∆∞∆°ng ng·ªçc l·∫•p l√°nh.",
        "V√¢n h√† m·ªü l·ªëi, r∆∞∆°ng huy·ªÅn quang t·ª´ xa bay t·ªõi.",
        "ƒê√†i t·∫ø c·ªï n·ªïi l√™n, r∆∞∆°ng kh·∫Øc ph√π vƒÉn ti√™n gia.",
        "H√†o quang t·ª• ƒë·ªânh, r∆∞∆°ng ch√≥i r√≥t xu·ªëng tay b·∫°n.",
        "Tinh t√∫ ƒë·ªïi v·ªã, r∆∞∆°ng thi√™n t∆∞·ª£ng r∆°i ƒë√∫ng t·ªça ƒë·ªô.",
        "Chu√¥ng c·ªï t·ª± ng√¢n ba h·ªìi, r∆∞∆°ng b√°u tr·ªìi kh·ªèi n·ªÅn ƒë·∫•t.",
        "Linh ƒëi·ªÉu d·∫´n ƒë∆∞·ªùng, r∆∞∆°ng b·∫£o v·∫≠t hi·ªán n∆°i l√≤ng ch·∫£o.",
        "Th·ªßy k√≠nh v·ª°, r∆∞∆°ng √°nh b·∫°c tr·ªìi l√™n nh∆∞ h√¥ ·ª©ng.",
        "S∆∞∆°ng m√π t√°n, r∆∞∆°ng b·∫°ch ng·ªçc hi·ªán gi·ªØa th·∫£o nguy√™n.",
        "ƒê√° tr·ªùi n·ª©t, r∆∞∆°ng ho√†ng kim t·ª´ l√µi ƒë√° l·ªô di·ªán.",
        "Th√°p c·ªï m·ªü m·∫Øt tr·∫≠n, r∆∞∆°ng ng·ªçc t·ª´ b·∫≠c thang tr√¥i xu·ªëng.",
        "Phong v√¢n bi·∫øn s·∫Øc, r∆∞∆°ng b√°u ƒë√°p xu·ªëng theo v·∫øt s√©t."
    ],
    "S": [
        "Thi√™n ƒë·ªãa dao ƒë·ªông ‚Äî r∆∞∆°ng th·∫ßn b√≠ ƒë√°p xu·ªëng nh∆∞ ti√™n nh√¢n g·ª≠i t·∫∑ng.",
        "Nh·∫≠p ƒë·ªãnh c·ª≠u thi√™n ‚Äî t·ªânh d·∫≠y ƒë√£ th·∫•y r∆∞∆°ng ch·ª©a b√≠ b·∫£o th·∫•t truy·ªÅn.",
        "M√¢y x√© tr·ªùi, r∆∞∆°ng th·∫ßn gi√°ng nh∆∞ s·∫Øc phong c·ª≠u thi√™n.",
        "C·ªï m·ªôc h√≥a r·ªìng r·ªìi tan ‚Äî r∆∞∆°ng kim s·∫Øc c√≤n l·∫°i nh∆∞ di v·∫≠t ti√™n gi·ªõi.",
        "T∆∞·ª£ng th·∫ßn m·ªü m·∫Øt, ƒë·∫°o √¢m vang ‚Äî r∆∞∆°ng ch√≠ t√¥n h·∫° xu·ªëng.",
        "TrƒÉng d·ª±ng T√¢y H·ªì, n∆∞·ªõc t√°ch ‚Äî r∆∞∆°ng ti√™n t·ª´ ƒë√°y h·ªì bay l√™n.",
        "C·ªïng th·ªùi kh√¥ng m·ªü, r∆∞∆°ng v√†ng t·ª´ xa x∆∞a trao quy·ªÅn th·ª´a k·∫ø.",
        "Tuy·∫øt phong t·ª• long ·∫£nh h√≥a r∆∞∆°ng, ƒë·∫•t tr·ªùi l·∫∑ng im.",
        "Thi√™n tinh r∆°i, r∆∞∆°ng nh·∫≠t nguy·ªát dung h·ª£p trong tay b·∫°n.",
        "V√¢n ki·∫øp ti√™u tan, r∆∞∆°ng thi√™n kim treo gi·ªØa kh√¥ng trung.",
        "ƒê·∫°o v·∫≠n h·ªôi t·ª• l√™n ƒë·ªânh ƒë·∫ßu ‚Äî r∆∞∆°ng th·∫ßn gi√°ng l·ªÖ t·∫•n phong.",
        "Long m·∫°ch chuy·ªÉn, r∆∞∆°ng ch√≠ t√¥n n·ª©t √°nh th·∫ßn vƒÉn.",
        "Chu thi√™n ƒë·∫°i tr·∫≠n k√≠ch ho·∫°t, r∆∞∆°ng ho√†ng c·ª±c xu·∫•t th·∫ø.",
        "Nguy·ªát quang ch·∫£y th√†nh su·ªëi, r∆∞∆°ng tinh di·ªáu n·ªïi b·ªìng b·ªÅnh.",
        "L√¥i ƒë√¨nh gi√°ng xu·ªëng, r∆∞∆°ng l·ª•c l√¥i an t·ªça b·∫•t ƒë·ªông.",
        "Ti√™n c·∫ßm h√°t kh√∫c ƒëƒÉng thi√™n, r∆∞∆°ng b·∫£o v√¢n thƒÉng h·∫°.",
        "V√¥ t·ª± thi√™n th∆∞ t·ª± l·∫≠t, r∆∞∆°ng kim quang xu·∫•t hi·ªán ·ªü ch∆∞∆°ng cu·ªëi.",
        "H·ªìn ƒë√®n mi·∫øu c·ªï b√πng ch√°y, r∆∞∆°ng x√≠ch kim bay kh·ªèi b·ªá.",
        "Thanh thi√™n m·ªü v·∫øt r·∫°n, r∆∞∆°ng thi√™n uy xuy√™n qua khe n·ª©t.",
        "Thi√™n ƒë·∫°o ban ·∫•n, r∆∞∆°ng th√°nh kh·∫Øc l·ªánh ƒë·ªì tr√™n n·∫Øp."
    ],
}
DISCORD_DESCRIPTIONS = {
    "D": [
        "B·∫°n tham gia event nh·∫π tr√™n Discord ‚Äî qu√† an ·ªßi l√† chi·∫øc r∆∞∆°ng g·ªó m·ªôc.",
        "Tin nh·∫Øn h·ªá th·ªëng ping: ‚ÄòB·∫°n c√≥ ph·∫ßn qu√† nh·ªè!‚Äô ‚Äî m·ªü ra r∆∞∆°ng c≈©.",
        "Channel #eventbang n·ªï th√¥ng b√°o ‚Äî b·∫°n k·ªãp claim r∆∞∆°ng nh·ªè.",
        "B·∫°n tr·∫£ l·ªùi ƒë√∫ng 1 c√¢u quiz ‚Äî ƒë∆∞·ª£c ph√°t r∆∞∆°ng b√© x√≠u.",
        "Admin ph√°t l√¨ x√¨ test ‚Äî b·∫°n nh·∫≠n m·ªôt r∆∞∆°ng ƒë∆°n s∆°.",
        "Bot g·ª≠i DM ‚Äònhi·ªám v·ª• h·∫±ng ng√†y‚Äô ‚Äî b·∫°n nh·∫≠n r∆∞∆°ng m·ªôc.",
        "B·∫°n gh√© k√™nh #chatbanghoi ‚Äî mod t·∫∑ng r∆∞∆°ng g·ªó.",
        "Ph·∫£n h·ªìi bug h·ª£p l·ªá ‚Äî ph·∫ßn qu√† l√† r∆∞∆°ng ph·ªß b·ª•i.",
        "B·∫°n online ƒë·ªß gi·ªù ‚Äî h·ªá th·ªëng t·∫∑ng r∆∞∆°ng b√©.",
        "Mini reaction game trao tay b·∫°n chi·∫øc r∆∞∆°ng nh·ªè.",
        "B·∫°n check-in k√™nh #chatchung ‚Äî rinh r∆∞∆°ng g·ªó mini.",
        "Nhi·ªám v·ª• ‚Äòch√†o h·ªèi‚Äô ho√†n th√†nh ‚Äî nh·∫≠n r∆∞∆°ng m·ªôc.",
        "K√™nh voice k·∫øt th√∫c ‚Äî b·∫°n ƒë∆∞·ª£c r∆∞∆°ng k·ª∑ ni·ªám.",
        "B·∫°n nh·∫≠n 1 l∆∞·ª£t ƒëua v·ªãt v√† tr√∫ng qu√† ‚Äî l√† r∆∞∆°ng nh·ªè xinh.",
        "ƒêua TOP 10 k·∫øt th√∫c ‚Äî b·∫°n l·ªçt top 10 v√† c√≥ r∆∞∆°ng.",
        "Sticker war vui v·∫ª ‚Äî mod t·∫∑ng r∆∞∆°ng an ·ªßi.",
        "B·∫°n report spam k·ªãp l√∫c ‚Äî nh·∫≠n r∆∞∆°ng c·∫£m ∆°n.",
        "Tham gia poll ‚Äî ph·∫ßn th∆∞·ªüng r∆∞∆°ng g·ªó b√©.",
        "B·∫°n test role m·ªõi ‚Äî bonus r∆∞∆°ng c≈©.",
        "B·∫°n ƒë√£ ‚Äòƒë·ªçc n·ªôi quy‚Äô xong ‚Äî h·ªá th·ªëng ph√°t r∆∞∆°ng m·ªôc."
    ],
    "C": [
        "Tham gia mini game gi·ªù v√†ng ‚Äî b·∫°n nh·∫≠n r∆∞∆°ng ph√°t s√°ng nh·∫π.",
        "Bot quay s·ªë ‚Äî t√™n b·∫°n hi·ªán l√™n, r∆∞∆°ng ƒë·ªìng nho nh·ªè v·ªÅ tay.",
        "B·∫°n ƒë·∫°t m·ªëc online tu·∫ßn ‚Äî h·ªá th·ªëng g·ª≠i r∆∞∆°ng mini.",
        "S·ª± ki·ªán sticker ƒë·∫°t m·ªëc ‚Äî b·∫°n c√≥ r∆∞∆°ng c·∫£m ∆°n.",
        "G√≥p √Ω giao di·ªán h·ª£p l√Ω ‚Äî mod t·∫∑ng r∆∞∆°ng nh·ªè.",
        "Ph·∫£n h·ªìi survey ‚Äî nh·∫≠n r∆∞∆°ng ƒë·ªìng.",
        "B·∫°n ho√†n th√†nh nhi·ªám v·ª• guild ‚Äî r∆∞∆°ng C g·ª≠i th·∫≥ng kho.",
        "K√™nh event th√¥ng b√°o: b·∫°n qualified ‚Äî r∆∞∆°ng nh·ªè unlock.",
        "B·∫°n gi·ªØ s·∫°ch k√™nh chat ‚Äî h·ªá th·ªëng th∆∞·ªüng r∆∞∆°ng.",
        "Ho√†n t·∫•t onboarding role ‚Äî bonus r∆∞∆°ng C v·ª´a tay.",
        "T∆∞∆°ng t√°c ƒë·∫°t streak ‚Äî r∆∞∆°ng mini ƒë∆∞·ª£c ph√°t.",
        "B·∫°n pass checkpoint quiz ‚Äî r∆∞∆°ng ƒë·ªìng v·ªÅ t√∫i.",
        "ƒê·∫°t c·∫•p ƒë·ªô chat 5 ‚Äî r∆∞∆°ng C auto claim.",
        "Tham gia thread x√¢y √Ω t∆∞·ªüng ‚Äî qu√† l√† r∆∞∆°ng nh·ªè.",
        "B·∫°n gi√∫p tr·∫£ l·ªùi t√¢n th·ªß ‚Äî bot ghi nh·∫≠n r∆∞∆°ng th∆∞·ªüng.",
        "Ch·ªët ng√†y c√¥ng c√°n b·ªô ‚Äî ph√°t r∆∞∆°ng mini tri √¢n.",
        "B·∫°n clear report ‚Äî r∆∞∆°ng ƒë·ªìng chuy·ªÉn kho·∫£n.",
        "Check in 7 ng√†y ‚Äî r∆∞∆°ng C xu·∫•t hi·ªán.",
        "Up meme ƒë√∫ng ch·ªß ƒë·ªÅ ‚Äî r∆∞∆°ng nh·ªè b·∫≠t n·∫Øp.",
        "B·∫°n review t√†i li·ªáu ‚Äî r∆∞∆°ng mini g·ª≠i nhanh."
    ],
    "B": [
        "Th·∫Øng b√°n k·∫øt event ‚Äî b·∫°n nh·∫≠n r∆∞∆°ng qu√Ω.",
        "ƒê·ª©ng top ph·∫£n h·ªìi tu·∫ßn ‚Äî r∆∞∆°ng B v·ªÅ tay.",
        "Clear bug quan tr·ªçng ‚Äî admin t·∫∑ng r∆∞∆°ng kh√≥a ƒë·ªìng.",
        "T·ªï ch·ª©c minigame th√†nh c√¥ng ‚Äî r∆∞∆°ng qu√Ω unlock.",
        "Ho√†n th√†nh guide chu·∫©n ‚Äî r∆∞∆°ng ch·∫°m b·∫°c xu·∫•t kho.",
        "ƒê·∫°t role ‚ÄòC·ªông t√°c‚Äô ‚Äî r∆∞∆°ng B chuy·ªÉn ph√°t nhanh.",
        "Lead voice room ‚Äî kho√° ƒë·ªìng b√†n giao.",
        "G·ª≠i pack emoji ch·∫•t l∆∞·ª£ng ‚Äî r∆∞∆°ng qu√Ω t·∫∑ng th∆∞·ªüng.",
        "Review rule chi ti·∫øt ‚Äî r∆∞∆°ng B ghi c√¥ng.",
        "Ch·ª•p banner ‚Äî r∆∞∆°ng qu√Ω c√≥ t√™n b·∫°n.",
        "H·ªó tr·ª£ event cross-server ‚Äî r∆∞∆°ng B v·ªÅ kho.",
        "Deploy bot test ·ªïn ‚Äî r∆∞∆°ng kh√≥a ƒë·ªìng ƒë·∫øn tay.",
        "C·ª©u k√®o ph√∫t ch√≥t ‚Äî r∆∞∆°ng qu√Ω t√¥n vinh.",
        "Thi·∫øt k·∫ø frame ƒë·ªôc ‚Äî r∆∞∆°ng B xu·∫•t hi·ªán.",
        "ƒê·∫°t KPI n·ªôi dung ‚Äî r∆∞∆°ng qu√Ω trao tay.",
        "Moderation nghi√™m t√∫c ‚Äî r∆∞∆°ng B tri √¢n.",
        "S∆∞u t·∫ßm lore server ‚Äî r∆∞∆°ng qu√Ω h·ªçc h·ªèi.",
        "Ghim t√†i li·ªáu chu·∫©n ‚Äî r∆∞∆°ng B open slot.",
        "T·ªëi ∆∞u k√™nh voice ‚Äî r∆∞∆°ng qu√Ω ch√∫c m·ª´ng.",
        "Bi√™n t·∫≠p recap ch·∫•t ‚Äî r∆∞∆°ng B l√™n ƒë∆∞·ªùng."
    ],
    "A": [
        "Th·∫Øng chung k·∫øt event ‚Äî r∆∞∆°ng ng·ªçc r·ª±c r·ª° xu·∫•t hi·ªán.",
        "L·∫≠p th√†nh t√≠ch ƒë·ªôt ph√° th√°ng ‚Äî r∆∞∆°ng b√°u A m·ªü slot.",
        "Push d·ª± √°n server th√†nh c√¥ng ‚Äî r∆∞∆°ng ch√¢u v·ªÅ tay.",
        "Thi·∫øt k·∫ø h·ªá th·ªëng role m·ªõi ‚Äî r∆∞∆°ng ng·ªçc ph√°t s√°ng.",
        "D·∫´n d·∫Øt chi·∫øn d·ªãch c·ªông ƒë·ªìng ‚Äî r∆∞∆°ng b√°u g·ª≠i t·∫∑ng.",
        "ƒê·∫°t k·ª∑ l·ª•c t∆∞∆°ng t√°c ‚Äî r∆∞∆°ng v√†ng A h·∫° c√°nh.",
        "Ph√°t hi·ªán l·ªó h·ªïng l·ªõn ‚Äî admin trao r∆∞∆°ng ng·ªçc.",
        "X√¢y onboarding x·ªãn ‚Äî r∆∞∆°ng b√°u tr√¨nh di·ªán.",
        "Rework theme ‚Äî r∆∞∆°ng A b·ª´ng s√°ng.",
        "Contributor of the Month ‚Äî r∆∞∆°ng b√°u ƒë·∫øn.",
        "ƒêi·ªÅu ph·ªëi gi·∫£i ƒë·∫•u ‚Äî r∆∞∆°ng A ghi nh·∫≠n.",
        "Thi·∫øt k·∫ø UX cho bot ‚Äî r∆∞∆°ng ng·ªçc on-chain v√†o kho.",
        "D·∫´n tour t√¢n th·ªß ‚Äî r∆∞∆°ng b√°u theo b·∫°n v·ªÅ.",
        "Vi·∫øt t√†i li·ªáu chu·∫©n h√≥a ‚Äî r∆∞∆°ng A thƒÉng ƒëi·ªÉm.",
        "Refactor bot th√†nh c√¥ng ‚Äî r∆∞∆°ng ch√¢u s√°ng r·ª°.",
        "K·∫øt n·ªëi c·ªông ƒë·ªìng ‚Äî r∆∞∆°ng b√°u c·∫≠p b·∫øn.",
        "Tri·ªÉn khai CDN ·∫£nh ‚Äî r∆∞∆°ng A th∆∞·ªüng n√≥ng.",
        "Series event d√†i h·∫°n ‚Äî r∆∞∆°ng b√°u m·ªü n·∫Øp.",
        "Lead hackathon n·ªôi b·ªô ‚Äî r∆∞∆°ng A vinh danh.",
        "·ªîn ƒë·ªãnh h·∫° t·∫ßng ƒë√™m b√£o ‚Äî r∆∞∆°ng b√°u A g·ª≠i t·ªõi."
    ],
    "S": [
        "To√†n server v·ªó tay ‚Äî b·∫°n nh·∫≠n r∆∞∆°ng th·∫ßn s·∫Øc nh∆∞ ‚Äòlegendary drop‚Äô.",
        "T√™n b·∫°n l√™n banner ‚Äî r∆∞∆°ng S ho√†ng kim xu·∫•t hi·ªán.",
        "ƒê·∫°i s·ª± ki·ªán th√†nh c√¥ng ‚Äî r∆∞∆°ng ch√≠ t√¥n gi√°ng l√¢m.",
        "B·∫°n gi·ªØ l·ª≠a c·ªông ƒë·ªìng ‚Äî r∆∞∆°ng th√°nh ban ·∫•n.",
        "ƒê∆∞a NTH Fan l√™n trending ‚Äî r∆∞∆°ng S r·ª±c s√°ng.",
        "V∆∞·ª£t KPI to√†n di·ªán ‚Äî r∆∞∆°ng ch√≠ t√¥n kh·∫Øc l·ªánh.",
        "K·∫øt n·ªëi li√™n minh server ‚Äî r∆∞∆°ng th·∫ßn ƒë·∫°o trao tay.",
        "C·ª©u server kh·ªèi crash ‚Äî r∆∞∆°ng S thi√™n quang gi√°ng.",
        "X√¢y v·∫≠n h√†nh b·ªÅn v·ªØng ‚Äî r∆∞∆°ng ch√≠ t√¥n xu·∫•t th·∫ø.",
        "M·ªü k·ª∑ nguy√™n s·ª± ki·ªán m·ªõi ‚Äî r∆∞∆°ng th√°nh r·ª±c r·ª°.",
        "D·∫´n d·∫Øt ƒë·∫°i l·ªÖ k·ª∑ ni·ªám ‚Äî r∆∞∆°ng S h·ªôi t·ª• phong v√¢n.",
        "H·ª£p nh·∫•t c·ªông ƒë·ªìng ph√¢n m·∫£nh ‚Äî r∆∞∆°ng th·∫ßn uy m·ªü kh√≥a.",
        "V·∫Ω b·∫£n ƒë·ªì t∆∞∆°ng lai server ‚Äî r∆∞∆°ng ch√≠ t√¥n ·∫•n k√Ω.",
        "ƒê·∫∑t n·ªÅn m√≥ng h·ªá th·ªëng m·ªõi ‚Äî r∆∞∆°ng S hi·ªÉn th√°nh.",
        "Chuy·ªÉn giao th·∫ø h·ªá m∆∞·ª£t m√† ‚Äî r∆∞∆°ng th√°nh v√†ng gi√°ng.",
        "Ki·∫øn t·∫°o vƒÉn h√≥a server ‚Äî r∆∞∆°ng th·∫ßn ban t·∫∑ng.",
        "Th·ªëng nh·∫•t ti√™u chu·∫©n n·ªôi b·ªô ‚Äî r∆∞∆°ng S ƒë√°p l·ªÖ.",
        "M·ªü c·ªïng s√°ng t·∫°o ng∆∞·ªùi d√πng ‚Äî r∆∞∆°ng ch√≠ t√¥n long lanh.",
        "ƒê·ªãnh h√¨nh b·∫£n s·∫Øc vƒ©nh c·ª≠u ‚Äî r∆∞∆°ng th√°nh kh·∫Øc danh.",
        "B·∫°n tr·ªü th√†nh bi·ªÉu t∆∞·ª£ng ‚Äî r∆∞∆°ng S theo b·∫°n nh∆∞ ·∫•n t√≠n."
    ],
}
def get_loot_description(map_name: str, rarity: str) -> str:
    pool = DISCORD_DESCRIPTIONS if map_name == MAP_DISCORD else DESCRIPTIONS
    arr = pool.get(rarity, DESCRIPTIONS.get("D", []))
    if not arr: arr = DESCRIPTIONS["D"]
    return random.choice(arr)

def choose_rarity():
    r = random.random(); acc=0.0
    for rar,p in RARITY_PROBS:
        acc += p
        if r <= acc: return rar
    return "D"

def get_nganphieu(r):
    lo,hi = NGANPHIEU_RANGE[r]
    return random.randint(lo,hi)

def gen_short_id(existing_ids:set):
    tries = 0
    while True:
        tries += 1
        iid = f"{random.randint(0,999):03d}"
        if iid not in existing_ids or tries>2000:
            return iid

def generate_item(rarity, user_items:list, item_type=None):
    if not item_type:
        item_type = random.choice(ITEM_TYPES)
    candidates = [n for (n,r) in ITEM_NAMES[item_type] if r==rarity]
    name = (random.choice(candidates) if candidates else ITEM_NAMES[item_type][0][0])
    lo,hi = ITEM_VALUE_RANGE[rarity]
    value = random.randint(lo,hi)
    existing = {it["id"] for it in user_items}
    iid = gen_short_id(existing)
    return {"id": iid, "name": name, "type": item_type, "rarity": rarity, "value": value, "equipped": False}
# ===== Rarity, map, m√¥ t·∫£ loot ‚Äî K·∫æT TH√öC =====

# ===== ·∫¢NH: helper attach tr·ªÖ =====
IMAGE_TIMEOUT_SEC = 2.5
async def _attach_image_later(ctx, message, embed, url, filename):
    try:
        file = await asyncio.wait_for(file_from_url_cached(url, filename), timeout=IMAGE_TIMEOUT_SEC)
        if file:
            embed.set_image(url=f"attachment://{filename}")
            try:
                await message.edit(embed=embed, attachments=[file])
            except TypeError:
                await ctx.send(embed=embed, file=file)
    except Exception:
        pass

def images_enabled_global() -> bool:
    data = load_data()
    cfg = data.get("config", {})
    return bool(cfg.get("images_enabled", True))

# =========================
# üîß H·ªÜ THAM CHI·∫æU CHUNG ‚Äî K·∫æT TH√öC
# =========================


# ===================================

# üß© BOT & C·∫§U H√åNH CHUNG ‚Äî B·∫ÆT ƒê·∫¶U
# ===================================
bot = commands.Bot(
    command_prefix=commands.when_mentioned_or("o","O"),
    intents=INTENTS,
    help_command=None,
    case_insensitive=True
)

@bot.event
async def on_ready():
    print(f"Bot ready: {bot.user} (id: {bot.user.id})")
    try:
        data = load_data()
        snapshot_data_v16(data, tag="startup", subkey="startup")
    except Exception:
        pass
# ===================================
# üß© BOT & C·∫§U H√åNH CHUNG ‚Äî K·∫æT TH√öC
# ===================================


# =================================================


# =================================================
# üß± QU·∫¢N L√ù ‚Äî ADMIN (module-style)
# =================================================
from discord import ui, ButtonStyle, Interaction

ADMIN_WHITELIST = {
    "setbot","osetbot",
    "lenhquantri","saoluu","listbackup","xemsaoluu",
    "phuchoi","resetdata","resetuser",
    "addtien","addruong",
    "gianlan","thabong","phattu",
    "batanh","pingg",
    "lenh","olenh"
}
GAMEPLAY_REQUIRE = {
    "ol","l",
    "okho","kho",
    "oxem","xem",
    "omac","mac",
    "othao","thao",
    "omo","mo",
    "oban","ban",
    "onhanvat","nhanvat",
    "odt","dt",
}

@bot.command(name="lenh", aliases=["olenh"])
async def cmd_olenh(ctx: commands.Context):
    desc = (
        "**‚öîÔ∏è L·ªÜNH C∆† B·∫¢N ‚Äî GAME NGH OFFLINE**\n\n"
        "`osetbot` ‚Äî K√≠ch ho·∫°t BOT trong k√™nh *(Admin)*\n"
        "`osetbot off` ‚Äî T·∫Øt BOT t·∫°m th·ªùi trong k√™nh\n"
        "`ol` ‚Äî ƒêi th√°m hi·ªÉm, t√¨m r∆∞∆°ng b√°u (CD 10s)\n"
        "`omo` ‚Äî M·ªü r∆∞∆°ng (VD: omo D / omo all)\n"
        "`odt` ‚Äî ƒê·ªï th·∫°ch (h·ªó tr·ª£ `odt all`)\n"
        "`okho` ‚Äî Xem kho ƒë·ªì\n"
        "`oban all` ‚Äî B√°n t·∫•t c·∫£ ch∆∞a m·∫∑c\n"
        "`omac <ID>` / `othao <ID>` / `oxem <ID>`\n"
        "`onhanvat` ‚Äî Ch·ªâ s·ªë nh√¢n v·∫≠t\n"
    )
    embed = discord.Embed(title="üìú DANH S√ÅCH L·ªÜNH C∆† B·∫¢N", description=desc, color=0xFFD700)
    embed.set_footer(text="BOT GAME NGH OFFLINE | NTH3.2")
    await ctx.reply(embed=embed, mention_author=False)

class SetBotView(ui.View):
    def __init__(self, timeout: float | None = 180):
        super().__init__(timeout=timeout)

    async def _is_admin_or_deny(self, interaction: Interaction) -> bool:
        perms = getattr(getattr(interaction.user, "guild_permissions", None), "administrator", False)
        if not perms:
            try:
                await interaction.response.send_message("‚ùå B·∫°n c·∫ßn quy·ªÅn **Qu·∫£n tr·ªã vi√™n** ƒë·ªÉ thao t√°c.", ephemeral=True)
            except Exception:
                pass
            return False
        return True

    @ui.button(label="‚ë† Set DUY NH·∫§T k√™nh n√†y", style=ButtonStyle.success, emoji="‚úÖ")
    async def btn_set_only(self, interaction: Interaction, button: ui.Button):
        if not await self._is_admin_or_deny(interaction): return
        data = load_data()
        set_guild_channels_only(data, interaction.guild.id, interaction.channel.id)
        save_data(data)
        await interaction.response.send_message(f"‚úÖ ƒê√£ **ch·ªâ ƒë·ªãnh duy nh·∫•t** k√™nh {interaction.channel.mention} cho BOT.", ephemeral=True)

    @ui.button(label="‚ë° G·ª° k√™nh n√†y", style=ButtonStyle.danger, emoji="üóëÔ∏è")
    async def btn_unset_here(self, interaction: Interaction, button: ui.Button):
        if not await self._is_admin_or_deny(interaction): return
        data = load_data()
        ok = remove_guild_channel(data, interaction.guild.id, interaction.channel.id)
        save_data(data)
        if ok:
            await interaction.response.send_message(f"üóëÔ∏è ƒê√£ g·ª° {interaction.channel.mention} kh·ªèi danh s√°ch k√™nh BOT.", ephemeral=True)
        else:
            await interaction.response.send_message(f"‚ÑπÔ∏è K√™nh {interaction.channel.mention} hi·ªán **kh√¥ng n·∫±m** trong danh s√°ch.", ephemeral=True)

    @ui.button(label="‚ë¢ Th√™m k√™nh ph·ª• (k√™nh n√†y)", style=ButtonStyle.primary, emoji="‚ûï")
    async def btn_add_here(self, interaction: Interaction, button: ui.Button):
        if not await self._is_admin_or_deny(interaction): return
        data = load_data()
        ok = add_guild_channel(data, interaction.guild.id, interaction.channel.id, max_channels=5)
        save_data(data)
        if ok:
            await interaction.response.send_message(f"‚ûï ƒê√£ **th√™m** {interaction.channel.mention} v√†o danh s√°ch k√™nh BOT.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ö†Ô∏è S·ªë l∆∞·ª£ng k√™nh ƒë√£ ƒë·∫°t gi·ªõi h·∫°n. H√£y g·ª° b·ªõt tr∆∞·ªõc khi th√™m.", ephemeral=True)

    @ui.button(label="‚ë£ Xem k√™nh ƒë√£ set", style=ButtonStyle.secondary, emoji="üìã")
    async def btn_list(self, interaction: Interaction, button: ui.Button):
        if not await self._is_admin_or_deny(interaction): return
        data = load_data()
        allowed = list(get_guild_channels(data, interaction.guild.id))
        if not allowed:
            await interaction.response.send_message("üìã Ch∆∞a c√≥ k√™nh n√†o ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh. H√£y d√πng c√°c n√∫t ‚ë† ho·∫∑c ‚ë¢.", ephemeral=True); return
        mentions = []
        for cid in allowed:
            ch = interaction.guild.get_channel(int(cid))
            mentions.append(ch.mention if ch else f"`#{cid}`")
        await interaction.response.send_message("üìã **Danh s√°ch k√™nh BOT:** " + " ‚Ä¢ ".join(mentions), ephemeral=True)

@bot.command(name="setbot", aliases=["osetbot"])
@commands.has_guild_permissions(administrator=True)
async def cmd_setbot(ctx: commands.Context):
    note = (
        "‚ö†Ô∏è BOT d√πng ti·ªÅn t·ªë `o` ho·∫∑c `O`.\n"
        "Ch·ªâ ƒë·ªãnh 1 k√™nh ri√™ng (ho·∫∑c k√™nh ph·ª•) ƒë·ªÉ tr√°nh tr√πng BOT kh√°c.\n"
        "Nh·∫•n c√°c n√∫t b√™n d∆∞·ªõi ƒë·ªÉ c·∫•u h√¨nh nhanh."
    )
    await ctx.send(note, view=SetBotView())

# on_command_error equivalent
def _looks_like_noise_o(msg: str) -> bool:
    if not msg: return False
    s = msg.strip().lower()
    if not s: return False
    first = s.split()[0]
    if first in IGNORE_O_TOKENS: return True
    if set(first) == {"o"}: return True
    for t in IGNORE_O_TOKENS:
        if first.startswith("o"+t): return True
    return False

@bot.event
async def on_command_error(ctx: commands.Context, error):
    if isinstance(error, commands.CheckFailure):
        return
    if isinstance(error, commands.CommandNotFound):
        try:
            if _looks_like_noise_o(getattr(ctx.message, "content", "")):
                return
        except Exception:
            pass
        if ctx.guild:
            try:
                data = load_data()
                allowed = get_guild_channels(data, ctx.guild.id)
            except Exception:
                allowed = set()
            if not allowed or (ctx.channel.id not in allowed):
                return
        await ctx.reply("‚ùì L·ªánh kh√¥ng t·ªìn t·∫°i. D√πng `olenh` ƒë·ªÉ xem danh s√°ch.", mention_author=False)
        return
    if isinstance(error, commands.CommandOnCooldown):
        await ctx.reply(f"‚è≥ Vui l√≤ng ch·ªù th√™m {int(error.retry_after)} gi√¢y.", mention_author=False); return
    if isinstance(error, commands.MissingRequiredArgument):
        name = getattr(ctx.command, "name", "")
        if name in {"mac","thao","xem"}:
            await ctx.reply(f"üìù L·ªánh `{name}` c·∫ßn ID. V√≠ d·ª•: `{name} 123`.", mention_author=False); return
        if name in {"dt"}:
            await ctx.reply("üìù D√πng: `odt <s·ªë_ng√¢n_phi·∫øu>` ‚Äî v√≠ d·ª•: `odt 1000`.", mention_author=False); return
        await ctx.reply("üìù Thi·∫øu tham s·ªë. D√πng `olenh` ƒë·ªÉ xem c√∫ ph√°p.", mention_author=False); return
    if isinstance(error, commands.BadArgument):
        name = getattr(ctx.command, "name", "")
        if name in {"dt"}:
            await ctx.reply("‚ö†Ô∏è S·ªë ti·ªÅn c∆∞·ª£c kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `odt 500`.", mention_author=False); return
        if name in {"addtien","addruong"}:
            await ctx.reply("‚ö†Ô∏è S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `oaddtien @user 1,000`.", mention_author=False); return
        await ctx.reply("‚ö†Ô∏è Tham s·ªë kh√¥ng h·ª£p l·ªá. Ki·ªÉm tra l·∫°i c√∫ ph√°p.", mention_author=False); return

@bot.check
async def global_channel_check(ctx: commands.Context):
    if not ctx.guild:  # DM
        return True
    if ctx.command is None:
        return True
    cmd_names = {ctx.command.name.lower(), *[a.lower() for a in getattr(ctx.command, "aliases", [])]}
    if cmd_names & ADMIN_WHITELIST:
        return True
    if cmd_names & GAMEPLAY_REQUIRE:
        data = load_data()
        allowed = get_guild_channels(data, ctx.guild.id)
        if not allowed or (ctx.channel.id not in allowed):
            msg = (
                "‚ö†Ô∏è BOT s·ª≠ d·ª•ng ti·ªÅn t·ªë `o` ho·∫∑c `O`.\n"
                "Y√™u c·∫ßu Admin d√πng **`osetbot`** ƒë·ªÉ ch·ªâ ƒë·ªãnh k√™nh ch·∫°y BOT cho server n√†y."
            )
            try:
                await ctx.reply(msg, mention_author=False)
            except Exception:
                await ctx.send(msg)
            return False
    return True
# =================================================


# ==================================
# üßë‚Äç‚öñÔ∏è QU·∫¢N L√ù ‚Äî CH·ª¶ BOT (module-style)
# ==================================
BOT_OWNERS = {821066331826421840}

def is_owner_user(user, bot):
    try:
        app = bot.application
        if app and app.owner and user.id == app.owner.id:
            return True
    except Exception:
        pass
    return user.id in BOT_OWNERS

def owner_only():
    async def predicate(ctx):
        return is_owner_user(ctx.author, ctx.bot)
    return commands.check(predicate)

def _get_user_ref(data: dict, member: discord.Member):
    uid = str(member.id)
    gid = str(getattr(getattr(member, "guild", None), "id", None)) if getattr(member, "guild", None) else None
    users = data.setdefault("users", {})
    if uid in users: return users[uid], "users"
    if gid and "guilds" in data and gid in data["guilds"]:
        g = data["guilds"][gid]
        if "users" in g and uid in g["users"]:
            return g["users"][uid], f"guilds[{gid}].users"
    if "players" in data and uid in data["players"]:
        return data["players"][uid], "players"
    u = users.setdefault(uid, {})
    return u, "users (new)"

def get_balance(u: dict) -> int:
    return int(u.get("ngan_phi", u.get("ngan_phieu", 0)))

def set_balance(u: dict, value: int) -> None:
    u["ngan_phi"] = int(value)
    if "ngan_phieu" in u:
        u.pop("ngan_phieu", None)

def ensure_rungs(u: dict) -> dict:
    legacy = u.pop("ruong", None)
    r = u.setdefault("rungs", {})
    if isinstance(legacy, dict):
        for k, v in legacy.items():
            if isinstance(v, int) and k in ("D","C","B","A","S"):
                r[k] = r.get(k, 0) + v
    for k in ("D","C","B","A","S"):
        r.setdefault(k, 0)
    return r

@bot.command(name="lenhquantri")
@owner_only()
async def cmd_olenhquantri(ctx):
    lines = [
        "**L·ªÜNH CH·ª¶ BOT (Owner)**",
        "`saoluu` ‚Äî T·∫°o backup th·ªß c√¥ng",
        "`listbackup [limit]` ‚Äî Li·ªát k√™ backup g·∫ßn ƒë√¢y",
        "`xemsaoluu` ‚Äî Xem th·ªëng k√™ backup",
        "`phuchoi [filename]` ‚Äî Kh√¥i ph·ª•c d·ªØ li·ªáu",
        "`resetdata` ‚Äî Reset to√†n b·ªô d·ªØ li·ªáu (gi·ªØ config)",
        "`resetuser @user` ‚Äî Reset d·ªØ li·ªáu 1 ng∆∞·ªùi",
        "`addtien @user <s·ªë>` ‚Äî C·ªông Ng√¢n Phi·∫øu",
        "`addruong @user <ph·∫©m> <s·ªë>` ‚Äî C·∫•p r∆∞∆°ng",
        "`xtien @user` ‚Äî Ch·∫©n ƒëo√°n s·ªë d∆∞ & nh√°nh l∆∞u",
        "`batanh [on|off]` ‚Äî B·∫≠t/t·∫Øt hi·ªÉn th·ªã ·∫£nh",
    ]
    await ctx.reply("\n".join(lines), mention_author=False)

@bot.command(name="saoluu")
@owner_only()
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_osaoluu(ctx):
    data = load_data()
    try:
        path = snapshot_data_v16(data, tag="manual", subkey="manual")
        await ctx.reply(f"‚úÖ ƒê√£ t·∫°o b·∫£n sao l∆∞u: `{os.path.basename(path)}`", mention_author=False)
    except Exception as e:
        await ctx.reply(f"‚ö†Ô∏è Sao l∆∞u th·∫•t b·∫°i: {e}", mention_author=False)

@bot.command(name="listbackup")
@owner_only()
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_olistbackup(ctx, limit: int = 10):
    recents = list_recent_backups_v16(limit=limit)
    if not recents:
        return await ctx.reply("Kh√¥ng t√¨m th·∫•y b·∫£n sao l∆∞u n√†o.", mention_author=False)
    lines = ["**C√°c b·∫£n sao l∆∞u g·∫ßn ƒë√¢y:**"]
    for ts, key, path in recents:
        base = os.path.basename(path)
        lines.append(f"- `{base}` ‚Äî **{key}**")
    await ctx.reply("\n".join(lines), mention_author=False)

@bot.command(name="xemsaoluu")
@owner_only()
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_oxemsaoluu(ctx):
    st = total_backup_stats_v16()
    mb = st["bytes"] / (1024*1024) if st["bytes"] else 0.0
    latest = os.path.basename(st["latest"]) if st["latest"] else "‚Äî"
    msg = (f"**Th·ªëng k√™ backup**\n"
           f"- S·ªë file: **{st['files']}**\n"
           f"- Dung l∆∞·ª£ng: **{mb:.2f} MB**\n"
           f"- G·∫ßn nh·∫•t: `{latest}`")
    await ctx.reply(msg, mention_author=False)

@bot.command(name="batanh")
@owner_only()
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_batanh(ctx, mode: str = None):
    data = load_data()
    cfg = data.setdefault("config", {})
    if mode is None:
        status = "B·∫¨T" if cfg.get("images_enabled", True) else "T·∫ÆT"
        await ctx.reply(f"Hi·ªÉn th·ªã ·∫£nh hi·ªán t·∫°i: {status}", mention_author=False); return
    m = (mode or "").strip().lower()
    if m in ("on","b·∫≠t","bat","enable","enabled","true","1"):
        cfg["images_enabled"] = True; save_data(data)
        await ctx.reply("‚úÖ ƒê√£ B·∫¨T hi·ªÉn th·ªã ·∫£nh.", mention_author=False); return
    if m in ("off","t·∫Øt","tat","disable","disabled","false","0"):
        cfg["images_enabled"] = False; save_data(data)
        await ctx.reply("‚úÖ ƒê√£ T·∫ÆT hi·ªÉn th·ªã ·∫£nh.", mention_author=False); return
    await ctx.reply("D√πng: `obatanh on` ho·∫∑c `obatanh off`.", mention_author=False)

@bot.command(name="addtien")
@owner_only()
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_addtien(ctx, member: discord.Member, so: str):
    try:
        amount = int(str(so).replace(",", "").strip())
        if amount <= 0: raise ValueError()
    except Exception:
        await ctx.reply("‚ö†Ô∏è S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `oaddtien @user 1,000,000`.", mention_author=False); return
    data = load_data()
    u, path = _get_user_ref(data, member)
    bal = get_balance(u)
    set_balance(u, bal + amount)
    save_data(data)
    await ctx.reply(f"‚úÖ C·ªông `{format_num(amount)}` NP cho `{member.display_name}` ‚Äî T·ªïng: `{format_num(get_balance(u))}`", mention_author=False)

@bot.command(name="addruong")
@owner_only()
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_addruong(ctx, member: discord.Member, pham: str, so: str):
    pham = pham.strip().upper()
    if pham not in {"D","C","B","A","S"}:
        await ctx.reply("Ph·∫©m r∆∞∆°ng kh√¥ng h·ª£p l·ªá. D√πng: D/C/B/A/S", mention_author=False); return
    try:
        amount = int(str(so).replace(",", "").strip())
        if amount <= 0: raise ValueError()
    except Exception:
        await ctx.reply("‚ö†Ô∏è S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `oaddruong @user S 3`.", mention_author=False); return
    if amount > 10:
        await ctx.reply("‚ö†Ô∏è T·ªëi ƒëa **10 r∆∞∆°ng** m·ªói l·∫ßn.", mention_author=False); return
    data = load_data()
    u, path = _get_user_ref(data, member)
    r = ensure_rungs(u); r[pham] = int(r.get(pham, 0)) + amount
    save_data(data)
    await ctx.reply(f"‚úÖ ƒê√£ c·∫•p `{format_num(amount)}` r∆∞∆°ng **{pham}** cho `{member.display_name}` ‚Äî T·ªïng: `{format_num(r[pham])}`", mention_author=False)

@bot.command(name="xtien")
@owner_only()
@commands.cooldown(1, 3, commands.BucketType.user)
async def cmd_oxtien(ctx, member: discord.Member):
    data = load_data()
    u, path = _get_user_ref(data, member)
    keys = {k: u[k] for k in ("ngan_phi","ngan_phieu") if k in u}
    rinfo = u.get("rungs", {})
    bal = int(u.get("ngan_phi", u.get("ngan_phieu", 0)))
    await ctx.reply(f"üß© Path: **{path}**\nüí∞ S·ªë d∆∞: **{format_num(bal)}** (keys: {keys})\nüéÅ R∆∞∆°ng: {rinfo}", mention_author=False)

@bot.command(name="phuchoi")
@owner_only()
@commands.cooldown(1, 10, commands.BucketType.user)
async def cmd_phuchoi(ctx, filename: str = None):
    data = load_data()
    try: snapshot_data_v16(data, tag="before-restore", subkey="before_restore")
    except Exception: pass
    
    path = None
    if filename:
        cand = os.path.join(BACKUP_DIR, filename)
        if os.path.isfile(cand): path = cand
    else:
        recents = list_recent_backups_v16(limit=1)
        if recents: _, _, path = recents[0]
    if not path or not os.path.isfile(path):
        await ctx.reply("Kh√¥ng t√¨m th·∫•y file backup ph√π h·ª£p.", mention_author=False); return
    try:
        with open(path, "r", encoding="utf-8") as f:
            restored = json.load(f)
        save_data(restored)
        await ctx.reply(f"‚úÖ ƒê√£ kh√¥i ph·ª•c d·ªØ li·ªáu t·ª´: `{os.path.basename(path)}`", mention_author=False)
    except Exception as e:
        await ctx.reply(f"Kh√¥i ph·ª•c th·∫•t b·∫°i: {e}", mention_author=False)

@bot.command(name="resetdata")
@owner_only()
@commands.cooldown(1, 10, commands.BucketType.user)
async def cmd_resetdata(ctx):
    data = load_data()
    try: snapshot_data_v16(data, tag="before-resetdata", subkey="before_resetdata")
    except Exception: pass
    new_data = {}
    if "guild_settings" in data: new_data["guild_settings"] = data["guild_settings"]
    if "config" in data and isinstance(data["config"], dict): new_data["config"] = data["config"]
    if "server_cfg" in data and isinstance(data["server_cfg"], dict): new_data["server_cfg"] = data["server_cfg"]
    save_data(new_data)
    await ctx.reply("‚úÖ ƒê√£ reset d·ªØ li·ªáu (gi·ªØ c·∫•u h√¨nh k√™nh & thi·∫øt l·∫≠p ·∫£nh).", mention_author=False)

@bot.command(name="resetuser")
@owner_only()
@commands.cooldown(1, 10, commands.BucketType.user)
async def cmd_resetuser(ctx, member: discord.Member):
    data = load_data()
    try: snapshot_data_v16(data, tag="before-resetuser", subkey="before_resetuser")
    except Exception: pass
    users = data.setdefault("users", {})
    uid = str(member.id)
    had = users.pop(uid, None)
    save_data(data)
    if had is not None:
        await ctx.reply(f"‚úÖ ƒê√£ reset d·ªØ li·ªáu: `{member.display_name}`.", mention_author=False)
    else:
        await ctx.reply(f"Ng∆∞·ªùi ch∆°i `{member.display_name}` ch∆∞a c√≥ d·ªØ li·ªáu.", mention_author=False)


# ======================
# üßç KHU V·ª∞C: NH√ÇN V·∫¨T (module-style)
# ======================
@bot.command(name="nhanvat", aliases=["onhanvat"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_onhanvat(ctx, member: discord.Member=None):
    target = member or ctx.author
    user_id = str(target.id)
    data = ensure_user(user_id)
    user = data["users"][user_id]

    equip_lines=[]
    for slot, iid in user["equipped"].items():
        if iid:
            it = next((x for x in user["items"] if x["id"]==iid), None)
            if it:
                equip_lines.append(f"{RARITY_EMOJI[it['rarity']]} `{it['id']}` {it['name']} ‚Äî {it['type']}")

    emb = make_embed(f"üß≠ Nh√¢n v·∫≠t ‚Äî {target.display_name}", color=0x9B59B6, footer=f"Y√™u c·∫ßu b·ªüi {ctx.author.display_name}")
    emb.add_field(name=f"{NP_EMOJI} Ng√¢n Phi·∫øu", value=format_num(user.get('ngan_phi',0)), inline=True)
    emb.add_field(name="Trang b·ªã ƒëang m·∫∑c", value="\n".join(equip_lines) if equip_lines else "Kh√¥ng c√≥", inline=False)

    if images_enabled_global():
        try:
            file = await file_from_url_cached(IMG_NHAN_VAT, "nhanvat.png")
            emb.set_image(url="attachment://nhanvat.png")
            await ctx.send(embed=emb, file=file)
            return
        except Exception:
            pass
    await ctx.send(embed=emb)

# =======================
# üõ°Ô∏è KHU V·ª∞C: TRANG B·ªä (module-style)
# =======================
def slot_of(item_type: str):
    return "slot_aogiap" if item_type == "√Åo Gi√°p" else "slot_vukhi"

class KhoView(discord.ui.View):
    def __init__(self, author_id:int, items:list, page:int=0, per_page:int=10, timeout:float=180.0):
        super().__init__(timeout=timeout)
        self.author_id = author_id
        self.items = items
        self.page = page
        self.per_page = per_page
        self.max_page = max(0, (len(items)-1)//per_page)
        self.children[0].disabled = (self.page==0)
        self.children[1].disabled = (self.page==self.max_page)
    def slice(self):
        a = self.page*self.per_page; b = a+self.per_page
        return self.items[a:b]
    async def update_msg(self, interaction: discord.Interaction):
        if interaction.user.id != self.author_id:
            await interaction.response.send_message("‚ùó Ch·ªâ ch·ªß kho m·ªõi thao t√°c ƒë∆∞·ª£c.", ephemeral=True); return
        content = "\n".join([f"{RARITY_EMOJI[it['rarity']]} `{it['id']}` {it['name']} ‚Äî {it['type']}" for it in self.slice()]) or "Kh√¥ng c√≥ v·∫≠t ph·∫©m"
        emb = interaction.message.embeds[0]
        emb.set_field_at(2, name="Trang b·ªã", value=content, inline=False)
        emb.set_footer(text=f"Trang {self.page+1}/{self.max_page+1}")
        self.children[0].disabled = (self.page==0)
        self.children[1].disabled = (self.page==self.max_page)
        await interaction.response.edit_message(embed=emb, view=self)
    @discord.ui.button(label="‚óÄ Tr∆∞·ªõc", style=discord.ButtonStyle.secondary)
    async def prev(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.page>0: self.page -= 1
        await self.update_msg(interaction)
    @discord.ui.button(label="Ti·∫øp ‚ñ∂", style=discord.ButtonStyle.secondary)
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.page<self.max_page: self.page += 1
        await self.update_msg(interaction)

@bot.command(name="kho", aliases=["okho"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_okho(ctx):
    user_id = str(ctx.author.id)
    data = ensure_user(user_id)
    user = data["users"][user_id]

    items_show = [it for it in user["items"] if not it["equipped"]]
    page_items = items_show[:10]
    content = "\n".join([f"{RARITY_EMOJI[it['rarity']]} `{it['id']}` {it['name']} ‚Äî {it['type']}" for it in page_items]) or "Kh√¥ng c√≥ v·∫≠t ph·∫©m"
    page_total = max(1, (len(items_show) - 1)//10 + 1)

    emb = make_embed(f"üì¶ {ctx.author.display_name} ‚Äî Kho nh√¢n v·∫≠t", color=0x3498DB, footer=f"Trang 1/{page_total}")
    total_r = sum(int(user["rungs"][k]) for k in ["D","C","B","A","S"])
    rtext = (f"{RARITY_CHEST_EMOJI['D']} {format_num(user['rungs']['D'])}   "
             f"{RARITY_CHEST_EMOJI['C']} {format_num(user['rungs']['C'])}   "
             f"{RARITY_CHEST_EMOJI['B']} {format_num(user['rungs']['B'])}   "
             f"{RARITY_CHEST_EMOJI['A']} {format_num(user['rungs']['A'])}   "
             f"{RARITY_CHEST_EMOJI['S']} {format_num(user['rungs']['S'])}")
    emb.add_field(name=f"R∆∞∆°ng hi·ªán c√≥ ‚Äî {format_num(total_r)}", value=rtext, inline=False)
    emb.add_field(name=f"{NP_EMOJI} Ng√¢n phi·∫øu hi·ªán c√≥: {format_num(user['ngan_phi'])}", value="\u200b", inline=True)
    emb.add_field(name="Trang b·ªã", value=content, inline=False)
    stats_text = (f"R∆∞∆°ng ƒë√£ m·ªü: {format_num(user['stats']['opened'])}\n"
                  f"S·ªë l·∫ßn th√°m hi·ªÉm: {format_num(user['stats']['ol_count'])}\n"
                  f"{NP_EMOJI}T·ªïng NP ƒë√£ ki·∫øm ƒë∆∞·ª£c: {format_num(user['stats']['ngan_phi_earned_total'])}")
    emb.add_field(name="üìä Th·ªëng k√™", value=stats_text, inline=False)

    if images_enabled_global():
        try:
            file = await file_from_url_cached(IMG_KHO_DO, "khodo.png")
            emb.set_image(url="attachment://khodo.png")
            view = KhoView(ctx.author.id, items_show, page=0, per_page=10)
            view.children[0].disabled = True
            view.children[1].disabled = (len(items_show) <= 10)
            msg = await ctx.send(embed=emb, file=file, view=view)
            try:
                await asyncio.sleep(3)
                emb.set_image(url=discord.Embed.Empty)
                try:
                    await msg.edit(embed=emb, attachments=[], view=view)
                except TypeError:
                    await msg.edit(embed=emb, view=view)
            except Exception:
                pass
            return
        except Exception:
            pass
    view = KhoView(ctx.author.id, items_show, page=0, per_page=10)
    view.children[0].disabled = True
    view.children[1].disabled = (len(items_show) <= 10)
    await ctx.send(embed=emb, view=view)

@bot.command(name="mac", aliases=["omac"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_omac(ctx, item_id: str = None):
    if item_id is None:
        await ctx.reply("üìù C√°ch d√πng: `mac <ID>` (Xem ID trong `okho`).", mention_author=False); return
    user_id = str(ctx.author.id)
    data = ensure_user(user_id); user = data["users"][user_id]
    target = next((it for it in user["items"] if it["id"] == item_id), None)
    if not target: await ctx.reply("‚ùó Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m v·ªõi ID ƒë√≥.", mention_author=False); return
    if target["equipped"]: await ctx.reply("V·∫≠t ph·∫©m ƒëang ƒë∆∞·ª£c m·∫∑c.", mention_author=False); return
    slot = slot_of(target["type"])
    if user["equipped"][slot]:
        cur_id = user["equipped"][slot]
        cur_item = next((it for it in user["items"] if it["id"] == cur_id), None)
        await ctx.reply(f"üîß Slot ƒëang b·∫≠n b·ªüi **{cur_item['name']}** (ID {cur_item['id']}). H√£y d√πng `othao {cur_item['id']}` ƒë·ªÉ th√°o.", mention_author=False); return
    target["equipped"] = True
    user["equipped"][slot] = target["id"]
    save_data(data)
    emoji = RARITY_EMOJI[target["rarity"]]
    emb = make_embed(title="ü™Ñ M·∫∑c trang b·ªã", description=f"B·∫°n m·∫∑c {emoji} **{target['name']}** (ID `{target['id']}`)", color=RARITY_COLOR[target["rarity"]], footer=f"{ctx.author.display_name}")
    await ctx.send(embed=emb)

@bot.command(name="thao", aliases=["othao"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_othao(ctx, item_id: str = None):
    if item_id is None:
        await ctx.reply("üìù C√°ch d√πng: `thao <ID>` (Xem ID trong `okho`).", mention_author=False); return
    user_id = str(ctx.author.id)
    data = ensure_user(user_id); user = data["users"][user_id]
    target = next((it for it in user["items"] if it["id"] == item_id), None)
    if not target: await ctx.reply("‚ùó Kh√¥ng t√¨m th·∫•y v·∫≠t ph·∫©m v·ªõi ID ƒë√≥.", mention_author=False); return
    if not target["equipped"]: await ctx.reply("V·∫≠t ph·∫©m kh√¥ng ƒëang m·∫∑c.", mention_author=False); return
    slot = slot_of(target["type"])
    user["equipped"][slot] = None
    target["equipped"] = False
    save_data(data)
    emoji = RARITY_EMOJI[target["rarity"]]
    emb = make_embed(title="ü™∂ Th√°o trang b·ªã", description=f"ƒê√£ th√°o {emoji} **{target['name']}** (ID `{target['id']}`) ‚Üí ki·ªÉm tra l·∫°i Kho.", color=0x95A5A6, footer=f"{ctx.author.display_name}")
    await ctx.send(embed=emb)

@bot.command(name="xem", aliases=["oxem"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_oxem(ctx, item_id: str = None):
    if item_id is None:
        await ctx.reply("üìù C√°ch d√πng: `xem <ID>` (Xem ID trong `okho`).", mention_author=False); return
    user_id = str(ctx.author.id)
    data = ensure_user(user_id); user = data["users"][user_id]
    it = next((x for x in user["items"] if x["id"] == item_id), None)
    if not it: await ctx.reply("‚ùó Kh√¥ng t√¨m th·∫•y trang b·ªã v·ªõi ID ƒë√≥.", mention_author=False); return
    state = "ƒêang m·∫∑c" if it["equipped"] else "Trong kho"
    emoji = RARITY_EMOJI[it["rarity"]]
    emb = make_embed(title=f"{emoji} `{it['id']}` {it['name']}", description=f"Lo·∫°i: **{it['type']}** ‚Ä¢ Ph·∫©m: {emoji} ‚Ä¢ Tr·∫°ng th√°i: **{state}**", color=RARITY_COLOR[it["rarity"]], footer=ctx.author.display_name)
    img_url = ITEM_IMAGE.get(it["type"], IMG_BANDO_DEFAULT)
    if images_enabled_global():
        try:
            file = await file_from_url_cached(img_url, "item.png")
            emb.set_image(url="attachment://item.png")
            await ctx.send(embed=emb, file=file); return
        except Exception:
            pass
    await ctx.send(embed=emb)

# ===================
# üí∞ KHU V·ª∞C: KINH T·∫æ (module-style)
# ===================
COOLDOWN_OL = 10

def _rarity_order_index(r: str) -> int:
    order = ["S","A","B","C","D"]
    try: return order.index(r)
    except ValueError: return 99

def _pick_highest_available_rarity(user) -> str | None:
    for r in ["S","A","B","C","D"]:
        if int(user["rungs"].get(r, 0)) > 0:
            return r
    return None

def _open_one_chest(user, r: str):
    user["rungs"][r] = int(user["rungs"].get(r, 0)) - 1
    gp = get_nganphieu(r)
    user["ngan_phi"] = int(user.get("ngan_phi", 0)) + gp
    user.setdefault("stats", {})
    user["stats"]["ngan_phi_earned_total"] = int(user["stats"].get("ngan_phi_earned_total", 0)) + gp
    user["stats"]["opened"] = int(user["stats"].get("opened", 0)) + 1

    item = None
    try:
        if PROB_ITEM_IN_RUONG and (random.random() < PROB_ITEM_IN_RUONG):
            item = generate_item(r, user["items"])
            user["items"].append(item)
    except Exception:
        pass
    return gp, item

def _fmt_item_line(it) -> str:
    return f"{RARITY_EMOJI[it['rarity']]} `{it['id']}` {it['name']} ‚Äî Gi√° tr·ªã: {format_num(it['value'])}"

@bot.command(name="l", aliases=["ol"])
async def cmd_ol(ctx):
    user_id = str(ctx.author.id)
    data = ensure_user(user_id)
    user = data["users"][user_id]

    now = time.time()
    if now < user["cooldowns"]["ol"]:
        await ctx.reply(f"‚è≥ H√£y ch·ªù {int(user['cooldowns']['ol'] - now)} gi√¢y n·ªØa.", mention_author=False); return

    rarity = choose_rarity()
    map_loc = random.choice(MAP_POOL)

    user["rungs"][rarity] += 1
    user["stats"]["ol_count"] += 1
    user["cooldowns"]["ol"] = now + COOLDOWN_OL
    save_data(data)

    rarity_name = {"D":"Ph·ªï Th√¥ng","C":"Hi·∫øm","B":"Tuy·ªát Ph·∫©m","A":"S·ª≠ Thi","S":"Truy·ªÅn Thuy·∫øt"}[rarity]
    title = f"**[{map_loc}]** **{ctx.author.display_name}** Thu ƒë∆∞·ª£c R∆∞∆°ng trang b·ªã {rarity_name} {RARITY_CHEST_EMOJI[rarity]} x1"
    desc = get_loot_description(map_loc, rarity)
    emb = make_embed(title=title, description=desc, color=RARITY_COLOR[rarity], footer=ctx.author.display_name)

    if images_enabled_global():
        try:
            emb.set_image(url=MAP_IMAGES.get(rarity, IMG_BANDO_DEFAULT))
        except Exception:
            pass
    msg = await ctx.send(embed=emb)

    try:
        await asyncio.sleep(3)
        if emb.image:
            emb.set_image(url=discord.Embed.Empty)
            await msg.edit(embed=emb)
    except Exception:
        pass

@bot.command(name="mo", aliases=["omo"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_omo(ctx, *args):
    user_id = str(ctx.author.id)
    data = ensure_user(user_id)
    user = data["users"][user_id]
    argv = [a.strip().lower() for a in args]

    def _open_many_for_rarity(user, r: str, limit: int = 50):
        opened = 0; total_np = 0; items = []
        while opened < limit and int(user["rungs"].get(r, 0)) > 0:
            gp, it = _open_one_chest(user, r)
            opened += 1; total_np += gp
            if it: items.append(it)
        return opened, total_np, items

    if len(argv) == 1 and argv[0] == "all":
        LIMIT = 50
        opened = 0; total_np = 0; items = []; per_rarity = {"S":0,"A":0,"B":0,"C":0,"D":0}
        highest_seen = None
        for r in ["S","A","B","C","D"]:
            while opened < LIMIT and int(user["rungs"].get(r, 0)) > 0:
                gp, it = _open_one_chest(user, r)
                opened += 1; total_np += gp; per_rarity[r] += 1
                if it:
                    items.append(it)
                    if (highest_seen is None) or (_rarity_order_index(it["rarity"]) < _rarity_order_index(highest_seen)):
                        highest_seen = it["rarity"]
        if opened == 0:
            await ctx.reply("‚ùó B·∫°n kh√¥ng c√≥ r∆∞∆°ng ƒë·ªÉ m·ªü.", mention_author=False); return
        highest_for_title = highest_seen
        if not highest_for_title:
            for r in ["S","A","B","C","D"]:
                if per_rarity[r] > 0: highest_for_title = r; break
        title_emoji = RARITY_CHEST_OPENED_EMOJI.get(highest_for_title or "D", "üéÅ")
        title = f"{title_emoji} **{ctx.author.display_name}** ƒë√£ m·ªü x{opened} r∆∞∆°ng"
        emb = make_embed(title=title, color=0x2ECC71, footer=ctx.author.display_name)
        rewards_block = (f"{NP_EMOJI}\u2003Ng√¢n Phi·∫øu: **{format_num(total_np)}**\n"
                         f"{EMOJI_TRANG_BI_COUNT}\u2003Trang b·ªã: **{len(items)}**")
        emb.add_field(name="Ph·∫ßn th∆∞·ªüng nh·∫≠n ƒë∆∞·ª£c", value=rewards_block, inline=False)
        breakdown_lines = [f"{RARITY_EMOJI[r]} x{per_rarity[r]}" for r in ["S","A","B","C","D"] if per_rarity[r] > 0]
        if breakdown_lines:
            emb.add_field(name="ƒê√£ m·ªü", value="  ".join(breakdown_lines), inline=False)
        if items:
            lines = [_fmt_item_line(it) for it in items]
            if len(lines) > 10:
                extra = len(lines) - 10
                lines = lines[:10] + [f"... v√† {extra} m√≥n kh√°c"]
            emb.add_field(name="V·∫≠t ph·∫©m nh·∫≠n ƒë∆∞·ª£c", value="\n".join(lines), inline=False)
        remaining = sum(int(user["rungs"].get(r, 0)) for r in ["S","A","B","C","D"])
        if remaining > 0:
            emb.set_footer(text=f"C√≤n {remaining} r∆∞∆°ng ‚Äî d√πng omo all ho·∫∑c omo <ph·∫©m> all ƒë·ªÉ m·ªü ti·∫øp")
        save_data(data)
        await ctx.send(embed=emb); return

    if len(argv) >= 1 and argv[0] in {"d","c","b","a","s"}:
        r = argv[0].upper()
        available = int(user["rungs"].get(r, 0))
        if available <= 0:
            await ctx.reply(f"‚ùó B·∫°n kh√¥ng c√≥ r∆∞∆°ng ph·∫©m {r}.", mention_author=False); return
        req = 1
        if len(argv) >= 2:
            if argv[1] == "all":
                req = min(50, available)
            else:
                try:
                    req = int(argv[1].replace(",", ""))
                except Exception:
                    await ctx.reply("‚ö†Ô∏è S·ªë l∆∞·ª£ng kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `omo d 3` ho·∫∑c `omo d all`.", mention_author=False); return
                if req <= 0: await ctx.reply("‚ö†Ô∏è S·ªë l∆∞·ª£ng ph·∫£i > 0.", mention_author=False); return
                if req > 50: await ctx.reply("‚ö†Ô∏è M·ªói l·∫ßn ch·ªâ m·ªü t·ªëi ƒëa **50** r∆∞∆°ng.", mention_author=False); return
                if req > available: await ctx.reply(f"‚ö†Ô∏è B·∫°n ch·ªâ c√≥ **{available}** r∆∞∆°ng {r}.", mention_author=False); return
        opened, total_np, items = _open_many_for_rarity(user, r, limit=req)
        if opened == 0: await ctx.reply("‚ùó Kh√¥ng m·ªü ƒë∆∞·ª£c r∆∞∆°ng n√†o.", mention_author=False); return
        title_emoji = RARITY_CHEST_OPENED_EMOJI.get(r, "üéÅ")
        title = f"{title_emoji} **{ctx.author.display_name}** ƒë√£ m·ªü x{opened} r∆∞∆°ng"
        emb = make_embed(title=title, color=RARITY_COLOR.get(r, 0x95A5A6), footer=ctx.author.display_name)
        rewards_block = (f"{NP_EMOJI}\u2003Ng√¢n Phi·∫øu: **{format_num(total_np)}**\n"
                         f"{EMOJI_TRANG_BI_COUNT}\u2003Trang b·ªã: **{len(items)}**")
        emb.add_field(name="Ph·∫ßn th∆∞·ªüng nh·∫≠n ƒë∆∞·ª£c", value=rewards_block, inline=False)
        if items:
            lines = [_fmt_item_line(it) for it in items]
            if len(lines) > 10:
                extra = len(lines) - 10
                lines = lines[:10] + [f"... v√† {extra} m√≥n kh√°c"]
            emb.add_field(name="V·∫≠t ph·∫©m nh·∫≠n ƒë∆∞·ª£c", value="\n".join(lines), inline=False)
        remaining_r = int(user["rungs"].get(r, 0))
        if remaining_r > 0:
            emb.set_footer(text=f"C√≤n {remaining_r} r∆∞∆°ng {r} ‚Äî d√πng omo {r.lower()} all ƒë·ªÉ m·ªü ti·∫øp")
        save_data(data); await ctx.send(embed=emb); return

    r_found = _pick_highest_available_rarity(user)
    if not r_found: await ctx.reply("‚ùó B·∫°n kh√¥ng c√≥ r∆∞∆°ng ƒë·ªÉ m·ªü.", mention_author=False); return
    gp, item = _open_one_chest(user, r_found)
    save_data(data)
    highest_for_title = item["rarity"] if item else r_found
    title_emoji = RARITY_CHEST_OPENED_EMOJI.get(highest_for_title, "üéÅ")
    title = f"{title_emoji} **{ctx.author.display_name}** ƒë√£ m·ªü 1 r∆∞∆°ng"
    emb = make_embed(title=title, color=RARITY_COLOR.get(highest_for_title, 0x95A5A6), footer=ctx.author.display_name)
    rewards_block = (f"{NP_EMOJI}\u2003Ng√¢n Phi·∫øu: **{format_num(gp)}**\n"
                     f"{EMOJI_TRANG_BI_COUNT}\u2003Trang b·ªã: **{1 if item else 0}**")
    emb.add_field(name="Ph·∫ßn th∆∞·ªüng nh·∫≠n ƒë∆∞·ª£c", value=rewards_block, inline=False)
    if item:
        emb.add_field(name="V·∫≠t ph·∫©m nh·∫≠n ƒë∆∞·ª£c", value=_fmt_item_line(item), inline=False)
    await ctx.send(embed=emb)

@bot.command(name="ban", aliases=["oban"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_oban(ctx, *args):
    user_id=str(ctx.author.id); data=ensure_user(user_id); user=data["users"][user_id]
    args=list(args)
    def settle(lst):
        total=sum(it["value"] for it in lst)
        user["ngan_phi"]+=total
        user["stats"]["sold_count"]+=len(lst)
        user["stats"]["sold_value_total"]+=total
        return total
    if not args:
        await ctx.reply("C√∫ ph√°p: `oban all` ho·∫∑c `oban <D|C|B|A|S> all`", mention_author=False); return
    if args[0].lower()=="all":
        sell=[it for it in user["items"] if not it["equipped"]]
        if not sell: await ctx.reply("Kh√¥ng c√≥ trang b·ªã r·∫£nh ƒë·ªÉ b√°n.", mention_author=False); return
        total=settle(sell)
        user["items"]=[it for it in user["items"] if it["equipped"]]
        save_data(data)
        await ctx.send(embed=make_embed("üßæ B√°n v·∫≠t ph·∫©m", f"ƒê√£ b√°n **{len(sell)}** m√≥n ‚Äî Nh·∫≠n **{NP_EMOJI} {format_num(total)}**",  color=0xE67E22, footer=ctx.author.display_name)); return
    if len(args)>=2 and args[1].lower()=="all":
        rar=args[0].upper()
        if rar not in ["D","C","B","A","S"]:
            await ctx.reply("Ph·∫©m ch·∫•t kh√¥ng h·ª£p l·ªá (D/C/B/A/S).", mention_author=False); return
        sell=[it for it in user["items"] if (it["rarity"]==rar and not it["equipped"])]
        if not sell: await ctx.reply(f"Kh√¥ng c√≥ v·∫≠t ph·∫©m ph·∫©m ch·∫•t {rar} ƒë·ªÉ b√°n.", mention_author=False); return
        total=settle(sell)
        user["items"]=[it for it in user["items"] if not (it["rarity"]==rar and not it["equipped"])]
        save_data(data)
        await ctx.send(embed=make_embed("üßæ B√°n v·∫≠t ph·∫©m", f"ƒê√£ b√°n **{len(sell)}** m√≥n {rar} ‚Äî Nh·∫≠n **{NP_EMOJI} {format_num(total)}**", color=RARITY_COLOR.get(rar,0x95A5A6), footer=ctx.author.display_name)); return
    await ctx.reply("C√∫ ph√°p kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `oban all` ho·∫∑c `oban D all`.", mention_author=False)

# ----- ƒê·ªï th·∫°ch (odt/dt) + Jackpot (module-style) -----
ODT_MAX_BET        = 250_000
POOL_ON_LOSS_RATE  = 1.0
JACKPOT_PCT         = 0.10
JACKPOT_GATE        = 0.05
JACKPOT_BASE        = 0.02
JACKPOT_HOT_BOOST   = 0.01
JACKPOT_HOT_CAP     = 5.0
JACKPOT_WINDOW_SEC  = 5 * 60
JACKPOT_THRESH_MIN  = 10_000_000
JACKPOT_THRESH_MAX  = 12_000_000
JACKPOT_THRESH_STEP = 1_000_000

ODT_TEXTS_WIN = [
    "Vi√™n ƒë√° n·ªï s√°ng, kim quang l·∫•p l√°nh!",
    "B·ª•i v·ª° tung, l·ªô b·∫£o th·∫°ch th∆∞·ª£ng c·ªï!",
    "C√≥ k·∫ª tr·∫£ gi√° g·∫•p m∆∞·ªùi mu·ªën thu mua ngay!",
    "M·ªôt tia s√°ng v·ª•t l√™n, linh kh√≠ cu·ªìn cu·ªôn!",
    "Long ng√¢m m∆° h·ªì, b·∫£o v·∫≠t hi·ªán th√¢n!",
    "Kh·∫£m tr·∫≠n kh·ªüi ƒë·ªông, linh th·∫°ch h√≥a kim!",
]
ODT_TEXTS_LOSE = [
    "M·ªü ra... b·ª•i l√† b·ª•i.",
    "H√≥a tro t√†n tr∆∞·ªõc khi k·ªãp vui.",
    "Vi√™n ƒë√° v·ª° v·ª•n, l√≤ng b·∫°n c≈©ng v·∫≠y.",
    "ƒê√° bay m·∫•t. Kh√¥ng k·ªãp nh√¨n.",
    "B·∫°n ch∆∞a ƒë·∫≠p, n√≥ ƒë√£ n·ªï!",
    "M·ªçi ng∆∞·ªùi ƒëang ch·ªù... r·ªìi th·∫•t v·ªçng.",
    "Qu·∫° ƒëen c·∫Øp ƒë√°, bay m·∫•t ti√™u.",
    "B·∫°n run tay, ƒë√° r∆°i v·ª° lu√¥n.",
    "C√≥ c√¥ n∆∞∆°ng xinh ƒë·∫πp xin vi√™n ƒë√°. B·∫°n cho lu√¥n.",
    "Kh√≥i tr·∫Øng b·ªëc l√™n... ƒë√° gi·∫£ r·ªìi.",
]

def _odt_init_state(user: dict):
    mg = user.setdefault("minigames", {})
    odt = mg.setdefault("odt", {"win_streak": 0, "loss_streak": 0})
    return odt

def _odt_pick_outcome(odt_state: dict) -> int:
    w = int(odt_state.get("win_streak", 0)); l = int(odt_state.get("loss_streak", 0))
    base_p5, base_win = 0.005, 0.49
    delta = max(-0.04, min(0.04, (l - w) * 0.02))
    win_p = max(0.05, min(0.95, base_win + delta))
    p5 = min(base_p5, win_p); p2 = max(0.0, win_p - p5)
    r = random.random()
    if r < p5: return 5
    if r < p5 + p2: return 2
    return 0

def _jp(data: dict) -> dict:
    jp = data.setdefault("jackpot", {})
    jp.setdefault("pool", 0)
    jp.setdefault("hidden_threshold", 0)
    jp.setdefault("window_start", 0.0)
    jp.setdefault("hot_log", [])
    return jp

def _jp_next_threshold() -> int:
    return random.randint(JACKPOT_THRESH_MIN, JACKPOT_THRESH_MAX)

def _jp_is_window_open(jp: dict, now: float) -> bool:
    ws = float(jp.get("window_start", 0))
    return ws > 0 and (now - ws) <= JACKPOT_WINDOW_SEC

def _jp_open_window_if_needed(jp: dict, now: float):
    thr = int(jp.get("hidden_threshold", 0))
    if thr <= 0:
        thr = _jp_next_threshold()
        jp["hidden_threshold"] = thr
    if jp["pool"] >= thr and not _jp_is_window_open(jp, now):
        jp["window_start"] = now

def _jp_shift_threshold_if_expired(jp: dict, now: float):
    if jp.get("window_start", 0) and not _jp_is_window_open(jp, now):
        jp["hidden_threshold"] = int(jp.get("hidden_threshold", 0)) + JACKPOT_THRESH_STEP
        jp["window_start"] = 0

def _jp_record_hot(jp: dict, now: float):
    jp["hot_log"] = [t for t in jp.get("hot_log", []) if now - t <= 180.0]
    jp["hot_log"].append(now)

def _jp_hot_factor(jp: dict) -> float:
    recent = [t for t in jp.get("hot_log", []) if time.time() - t <= 180.0]
    return min(JACKPOT_HOT_CAP, len(recent) / 10.0)

def _try_jackpot(data: dict, member: discord.Member) -> int:
    now = time.time()
    jp = _jp(data)
    _jp_open_window_if_needed(jp, now)
    _jp_shift_threshold_if_expired(jp, now)
    _jp_record_hot(jp, now)

    pool = int(jp.get("pool", 0))
    thr  = int(jp.get("hidden_threshold", 0))
    if pool <= 0 or thr <= 0 or pool < thr or not _jp_is_window_open(jp, now):
        return 0
    if random.random() >= JACKPOT_GATE:
        return 0
    hot = _jp_hot_factor(jp)
    trigger = JACKPOT_BASE + min(JACKPOT_HOT_CAP * JACKPOT_HOT_BOOST, hot * JACKPOT_HOT_BOOST)
    if random.random() >= trigger:
        return 0
    gain = max(1, int(pool * JACKPOT_PCT))
    jp["pool"] = 0
    jp["hidden_threshold"] = _jp_next_threshold()
    jp["window_start"] = 0
    return gain

@bot.command(name="odt", aliases=["dt"])
@commands.cooldown(1, 5, commands.BucketType.user)
async def cmd_odt(ctx, amount: str = None):
    user_id = str(ctx.author.id)
    data = ensure_user(user_id)
    user = data["users"][user_id]
    odt_state = _odt_init_state(user)

    if amount is None:
        await ctx.reply("üí¨ D√πng: `odt <s·ªë ti·ªÅn>` ho·∫∑c `odt all`. V√≠ d·ª•: `odt 1,000`.", mention_author=False); return
    a = str(amount).strip().lower()
    if a == "all":
        amount_val = min(int(user.get("ngan_phi", 0)), ODT_MAX_BET)
        if amount_val <= 0:
            await ctx.reply("‚ùó S·ªë d∆∞ b·∫±ng 0 ‚Äî kh√¥ng th·ªÉ `odt all`.", mention_author=False); return
    else:
        try:
            amount_val = int(a.replace(",", ""))
            if amount_val <= 0: raise ValueError()
        except Exception:
            await ctx.reply("‚ö†Ô∏è S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá. V√≠ d·ª•: `odt 500`, `odt 1,000` ho·∫∑c `odt all`.", mention_author=False); return
        if amount_val > ODT_MAX_BET:
            await ctx.reply(f"‚ö†Ô∏è M·ªói v√°n t·ªëi ƒëa {format_num(ODT_MAX_BET)} Ng√¢n Phi·∫øu.", mention_author=False); return

    bal = int(user.get("ngan_phi", 0))
    if bal < amount_val:
        await ctx.reply(f"‚ùó B·∫°n kh√¥ng ƒë·ªß Ng√¢n Phi·∫øu. (Hi·ªán c√≥: {format_num(bal)})", mention_author=False); return

    user["ngan_phi"] = bal - amount_val
    save_data(data)

    outcome = _odt_pick_outcome(odt_state)
    try: map_name = random.choice(MAP_POOL)
    except Exception: map_name = random.choice(["Bi·ªán Kinh","ƒê√†o Kh√™ Th√¥n","Tam Thanh S∆°n","H√†ng Ch√¢u","T·ª´ Ch√¢u","Nh·∫°n M√¥n Quan"])

    title = f"ƒê·ªï Th·∫°ch ‚Äî {map_name}"
    color = 0x2ECC71 if outcome else 0xE74C3C
    jackpot_announce = ""

    if outcome == 0:
        odt_state["loss_streak"] += 1
        odt_state["win_streak"] = 0
        jp = _jp(data)
        jp["pool"] = int(jp.get("pool", 0)) + int(amount_val * POOL_ON_LOSS_RATE)
        text = random.choice(ODT_TEXTS_LOSE)
        desc = (f"**{ctx.author.display_name}** b·ªè ra **{format_num(amount_val)}** **Ng√¢n Phi·∫øu**\n"
                f"ƒê·ªÉ mua m·ªôt vi√™n ƒë√° {EMOJI_DOTHACHT} ph√°t s√°ng t·∫°i th·∫°ch ph∆∞·ªùng {map_name}.\n\n"
                f"üí¨ {text}\n"
                f"{EMOJI_DOTHACHTHUA} Tr·∫Øng tay thu v·ªÅ **0 Ng√¢n Phi·∫øu**.")
        gain = _try_jackpot(data, ctx.author)
        if gain > 0:
            user["ngan_phi"] += gain
            jp = _jp(data)
            jp["last_win"] = {
                "user_id": ctx.author.id,
                "name": ctx.author.display_name,
                "amount": int(gain),
                "ts": time.time(),
            }
            jackpot_announce = (f"\n\nüéâ **Qu·ªπ Th·∫°ch Ph∆∞·ªùng N·ªî H≈®!** {ctx.author.mention} nh·∫≠n **{format_num(gain)}** Ng√¢n Phi·∫øu.")
            try:
                await ctx.author.send(f"{NP_EMOJI} Ch√∫c m·ª´ng! B·∫°n v·ª´a tr√∫ng **{format_num(gain)}** NP t·ª´ Qu·ªπ Th·∫°ch Ph∆∞·ªùng.")
            except Exception:
                pass
        save_data(data)
    else:
        odt_state["win_streak"] += 1
        odt_state["loss_streak"] = 0
        reward = amount_val * outcome
        user["ngan_phi"] += reward
        text = random.choice(ODT_TEXTS_WIN)
        if outcome == 5:
            desc = (f"**{ctx.author.display_name}** b·ªè ra **{format_num(amount_val)}** **Ng√¢n Phi·∫øu**\n"
                    f"ƒê·ªÉ mua m·ªôt vi√™n ƒë√° {EMOJI_DOTHACHT} ph√°t s√°ng t·∫°i th·∫°ch ph∆∞·ªùng {map_name}.\n\n"
                    f"üí¨ {text}\n"
                    f"{EMOJI_DOTHACH} Th·∫≠t b·∫•t ng·ªù, ch·ªß th·∫°ch ph∆∞·ªùng t·ªï ch·ª©c ƒë·∫•u gi√° v·∫≠t ph·∫©m b·∫°n m·ªü!\n"
                    f"‚Äî Thu v·ªÅ x5 gi√° tr·ªã nh·∫≠n **{format_num(reward)} Ng√¢n Phi·∫øu!**")
        else:
            desc = (f"**{ctx.author.display_name}** b·ªè ra **{format_num(amount_val)}** **Ng√¢n Phi·∫øu**\n"
                    f"ƒê·ªÉ mua m·ªôt vi√™n ƒë√° {EMOJI_DOTHACHT} ph√°t s√°ng t·∫°i th·∫°ch ph∆∞·ªùng {map_name}.\n\n"
                    f"üí¨ {text}\n"
                    f"{EMOJI_DOTHACH} B·∫•t ng·ªù l√£i l·ªõn ‚Äî thu v·ªÅ **{format_num(reward)} Ng√¢n Phi·∫øu**!")
        _jp_open_window_if_needed(_jp(data), time.time())
        save_data(data)

    # Footer m·ªõi: hi·ªÉn th·ªã ng∆∞·ªùi tr√∫ng g·∫ßn nh·∫•t n·∫øu c√≥, KH√îNG c√≥ d√≤ng 'N·∫øu may m·∫Øn...'
    jp_now = _jp(data)
    pool_now = int(jp_now.get("pool", 0))
    footer_lines = [
        f"S·ªë d∆∞ hi·ªán t·∫°i: {format_num(user['ngan_phi'])} Ng√¢n Phi·∫øu",
        f"Qu·ªπ Th·∫°ch Ph∆∞·ªùng: {format_num(pool_now)} Ng√¢n Phi·∫øu",
    ]
    last_win = jp_now.get("last_win")
    if isinstance(last_win, dict) and last_win.get("name") and last_win.get("amount"):
        footer_lines.append(
            f"G·∫ßn nh·∫•t {last_win['name']} ƒë√£ nh·∫≠n {format_num(int(last_win['amount']))} Ng√¢n Phi·∫øu"
        )
    emb = make_embed(title=title, description=desc + jackpot_announce, color=color, footer="\n".join(footer_lines))
    await ctx.send(content=(ctx.author.mention if jackpot_announce else None), embed=emb)

@bot.command(name="pingg")
async def cmd_opingg(ctx):
    t0 = time.perf_counter()
    msg = await ctx.send("‚è±Ô∏è ƒêang ƒëo...")
    t1 = time.perf_counter()
    gateway_ms = int(bot.latency * 1000)
    send_ms = int((t1 - t0) * 1000)
    await msg.edit(content=f"üèì Gateway: {gateway_ms} ms ‚Ä¢ Send/edit: {send_ms} ms")

async def _main():
    ensure_data()
    # no cogs needed in module mode
    await bot.start(TOKEN)

if __name__ == "__main__":
    TOKEN = os.environ.get("TU_TIEN_BOT_TOKEN", "")
    if not TOKEN:
        print("Vui l√≤ng ƒë·∫∑t bi·∫øn m√¥i tr∆∞·ªùng TU_TIEN_BOT_TOKEN v·ªõi token bot c·ªßa b·∫°n.")
    else:
        import asyncio
        asyncio.run(_main())
# ================================
# üöÄ KH·ªûI T·∫†O & CH·∫†Y BOT ‚Äî K·∫æT TH√öC
